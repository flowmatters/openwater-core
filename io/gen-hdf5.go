// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/joelrahman/genny

package io

import (
	"bytes"
	"errors"
	"fmt"
	"reflect"
	"strings"

	"github.com/flowmatters/openwater-core/conv"
	"github.com/flowmatters/openwater-core/data"
	"github.com/flowmatters/openwater-core/util/slice"
	"gonum.org/v1/hdf5"
)

type H5RefFloat64 struct {
	Filename string
	Dataset  string
	Slice    [][]int
}

func (h H5RefFloat64) Load() (data.NDFloat64, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)
	// mu.RLock()
	// defer mu.RUnlock()

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	if h.Slice != nil {
		for _, s := range h.Slice {
			if s != nil {
				return h.loadSubset(ds)
			}
		}
	}

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	result := data.NewArrayFloat64(shape)
	impl := result.Unroll()
	ds.Read(&impl)
	return result, nil
}

func (h H5RefFloat64) loadSubset(ds *hdf5.Dataset) (data.NDFloat64, error) {
	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}
	shape := conv.UintsToInts(dims)

	offset, stride, count, block := makeHyperslab(h.Slice, shape)
	filespace := space
	err = filespace.SelectHyperslab(offset, stride, count, block)
	if err != nil {
		return nil, err
	}

	for dim, size := range shape {
		if h.Slice[dim] != nil {
			newSize := sliceSize(h.Slice[dim], size)
			shape[dim] = newSize
		}
	}
	ushape := conv.IntsToUints(shape)
	memSpace, err := hdf5.CreateSimpleDataspace(ushape, ushape)
	if err != nil {
		return nil, err
	}
	defer memSpace.Close()

	result := data.NewArrayFloat64(shape)
	impl := result.Unroll()
	err = ds.ReadSubset(&impl, memSpace, filespace)
	return result, err
}

func (h H5RefFloat64) Write(data data.NDFloat64) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)
	// mu.Lock()
	// defer mu.Unlock()
	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, data.Shape(), data.Get(data.NewIndex(0)), false)
	if err != nil {
		return err
	}
	defer ds.Close()

	arrAsSlice := data.Unroll()
	err = ds.Write(&arrAsSlice)
	if err != nil {
		return err
	}

	return nil
}

func (h H5RefFloat64) Create(shape []int, fillValue float64, compress bool) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, shape, fillValue, compress)
	if err == nil {
		ds.Close()
	}
	return err
}

func (h H5RefFloat64) WriteSlice(data data.NDFloat64, loc []int) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, false)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return err
	}
	defer ds.Close()

	filespace := ds.Space()
	defer filespace.Close()

	shp := conv.IntsToUints(data.Shape())
	stride_count := conv.IntsToUints(slice.Ones(len(loc)))
	err = filespace.SelectHyperslab(conv.IntsToUints(loc), stride_count, stride_count, shp)
	if err != nil {
		return err
	}

	memSpace, err := hdf5.CreateSimpleDataspace(shp, shp)
	if err != nil {
		return err
	}
	defer memSpace.Close()

	impl := data.Unroll()
	err = ds.WriteSubset(&impl, memSpace, filespace)

	return nil
}

func (h H5RefFloat64) LoadText() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	dt, err := ds.Datatype()
	defer dt.Close()

	if dt.GoType() != reflect.TypeOf("a string") {
		return nil, errors.New("Not a string type")
	}

	space := ds.Space()
	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	if len(dims) > 1 {
		return nil, errors.New("Can only read 1D data as text")
	}
	maxLen := int(dt.Size())
	nStrings := int(dims[0])
	characters := make([]byte, nStrings*maxLen)
	ds.Read(&characters)

	result := make([]string, dims[0])
	for i := 0; i < nStrings; i++ {
		theBytes := characters[(i * maxLen):((i + 1) * maxLen)]
		end := bytes.Index(theBytes, []byte{0})
		if end < 0 {
			end = maxLen
		}
		theBytes = theBytes[0:end]
		result[i] = string(theBytes)
	}
	return result, nil
}

func (h H5RefFloat64) GetDatasets() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_DATASET {
			result = append(result, name)
		}
	}
	return result, nil
}

func (h H5RefFloat64) GetGroups() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_GROUP {
			result = append(result, name)
		}
	}
	return result, nil
}

func ParseH5RefFloat64(path string) H5RefFloat64 {
	components := strings.Split(path, ":")
	return H5RefFloat64{components[0], components[1], nil}
}

func (h H5RefFloat64) Exists() bool {
	components := strings.Split(h.Dataset, "/")

	path := "/"
	for ix, comp := range components {
		ref := H5RefFloat64{Filename: h.Filename, Dataset: path}

		if ix == (len(components) - 1) {
			datasets, err := ref.GetDatasets()

			if err != nil {
				return false
			}
			if findInSlice(datasets, comp) >= 0 {
				return true
			}
		}

		groups, err := ref.GetGroups()

		if err != nil {
			return false
		}
		if findInSlice(groups, comp) < 0 {
			return false
		}

		path = fmt.Sprintf("%s/%s", path, comp)
	}

	return true
}

func (h H5RefFloat64) Shape() ([]int, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	return shape, nil
}

type H5RefFloat32 struct {
	Filename string
	Dataset  string
	Slice    [][]int
}

func (h H5RefFloat32) Load() (data.NDFloat32, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)
	// mu.RLock()
	// defer mu.RUnlock()

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	if h.Slice != nil {
		for _, s := range h.Slice {
			if s != nil {
				return h.loadSubset(ds)
			}
		}
	}

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	result := data.NewArrayFloat32(shape)
	impl := result.Unroll()
	ds.Read(&impl)
	return result, nil
}

func (h H5RefFloat32) loadSubset(ds *hdf5.Dataset) (data.NDFloat32, error) {
	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}
	shape := conv.UintsToInts(dims)

	offset, stride, count, block := makeHyperslab(h.Slice, shape)
	filespace := space
	err = filespace.SelectHyperslab(offset, stride, count, block)
	if err != nil {
		return nil, err
	}

	for dim, size := range shape {
		if h.Slice[dim] != nil {
			newSize := sliceSize(h.Slice[dim], size)
			shape[dim] = newSize
		}
	}
	ushape := conv.IntsToUints(shape)
	memSpace, err := hdf5.CreateSimpleDataspace(ushape, ushape)
	if err != nil {
		return nil, err
	}
	defer memSpace.Close()

	result := data.NewArrayFloat32(shape)
	impl := result.Unroll()
	err = ds.ReadSubset(&impl, memSpace, filespace)
	return result, err
}

func (h H5RefFloat32) Write(data data.NDFloat32) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)
	// mu.Lock()
	// defer mu.Unlock()
	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, data.Shape(), data.Get(data.NewIndex(0)), false)
	if err != nil {
		return err
	}
	defer ds.Close()

	arrAsSlice := data.Unroll()
	err = ds.Write(&arrAsSlice)
	if err != nil {
		return err
	}

	return nil
}

func (h H5RefFloat32) Create(shape []int, fillValue float32, compress bool) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, shape, fillValue, compress)
	if err == nil {
		ds.Close()
	}
	return err
}

func (h H5RefFloat32) WriteSlice(data data.NDFloat32, loc []int) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, false)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return err
	}
	defer ds.Close()

	filespace := ds.Space()
	defer filespace.Close()

	shp := conv.IntsToUints(data.Shape())
	stride_count := conv.IntsToUints(slice.Ones(len(loc)))
	err = filespace.SelectHyperslab(conv.IntsToUints(loc), stride_count, stride_count, shp)
	if err != nil {
		return err
	}

	memSpace, err := hdf5.CreateSimpleDataspace(shp, shp)
	if err != nil {
		return err
	}
	defer memSpace.Close()

	impl := data.Unroll()
	err = ds.WriteSubset(&impl, memSpace, filespace)

	return nil
}

func (h H5RefFloat32) LoadText() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	dt, err := ds.Datatype()
	defer dt.Close()

	if dt.GoType() != reflect.TypeOf("a string") {
		return nil, errors.New("Not a string type")
	}

	space := ds.Space()
	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	if len(dims) > 1 {
		return nil, errors.New("Can only read 1D data as text")
	}
	maxLen := int(dt.Size())
	nStrings := int(dims[0])
	characters := make([]byte, nStrings*maxLen)
	ds.Read(&characters)

	result := make([]string, dims[0])
	for i := 0; i < nStrings; i++ {
		theBytes := characters[(i * maxLen):((i + 1) * maxLen)]
		end := bytes.Index(theBytes, []byte{0})
		if end < 0 {
			end = maxLen
		}
		theBytes = theBytes[0:end]
		result[i] = string(theBytes)
	}
	return result, nil
}

func (h H5RefFloat32) GetDatasets() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_DATASET {
			result = append(result, name)
		}
	}
	return result, nil
}

func (h H5RefFloat32) GetGroups() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_GROUP {
			result = append(result, name)
		}
	}
	return result, nil
}

func ParseH5RefFloat32(path string) H5RefFloat32 {
	components := strings.Split(path, ":")
	return H5RefFloat32{components[0], components[1], nil}
}

func (h H5RefFloat32) Exists() bool {
	components := strings.Split(h.Dataset, "/")

	path := "/"
	for ix, comp := range components {
		ref := H5RefFloat32{Filename: h.Filename, Dataset: path}

		if ix == (len(components) - 1) {
			datasets, err := ref.GetDatasets()

			if err != nil {
				return false
			}
			if findInSlice(datasets, comp) >= 0 {
				return true
			}
		}

		groups, err := ref.GetGroups()

		if err != nil {
			return false
		}
		if findInSlice(groups, comp) < 0 {
			return false
		}

		path = fmt.Sprintf("%s/%s", path, comp)
	}

	return true
}

func (h H5RefFloat32) Shape() ([]int, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	return shape, nil
}

type H5RefInt32 struct {
	Filename string
	Dataset  string
	Slice    [][]int
}

func (h H5RefInt32) Load() (data.NDInt32, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)
	// mu.RLock()
	// defer mu.RUnlock()

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	if h.Slice != nil {
		for _, s := range h.Slice {
			if s != nil {
				return h.loadSubset(ds)
			}
		}
	}

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	result := data.NewArrayInt32(shape)
	impl := result.Unroll()
	ds.Read(&impl)
	return result, nil
}

func (h H5RefInt32) loadSubset(ds *hdf5.Dataset) (data.NDInt32, error) {
	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}
	shape := conv.UintsToInts(dims)

	offset, stride, count, block := makeHyperslab(h.Slice, shape)
	filespace := space
	err = filespace.SelectHyperslab(offset, stride, count, block)
	if err != nil {
		return nil, err
	}

	for dim, size := range shape {
		if h.Slice[dim] != nil {
			newSize := sliceSize(h.Slice[dim], size)
			shape[dim] = newSize
		}
	}
	ushape := conv.IntsToUints(shape)
	memSpace, err := hdf5.CreateSimpleDataspace(ushape, ushape)
	if err != nil {
		return nil, err
	}
	defer memSpace.Close()

	result := data.NewArrayInt32(shape)
	impl := result.Unroll()
	err = ds.ReadSubset(&impl, memSpace, filespace)
	return result, err
}

func (h H5RefInt32) Write(data data.NDInt32) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)
	// mu.Lock()
	// defer mu.Unlock()
	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, data.Shape(), data.Get(data.NewIndex(0)), false)
	if err != nil {
		return err
	}
	defer ds.Close()

	arrAsSlice := data.Unroll()
	err = ds.Write(&arrAsSlice)
	if err != nil {
		return err
	}

	return nil
}

func (h H5RefInt32) Create(shape []int, fillValue int32, compress bool) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, shape, fillValue, compress)
	if err == nil {
		ds.Close()
	}
	return err
}

func (h H5RefInt32) WriteSlice(data data.NDInt32, loc []int) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, false)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return err
	}
	defer ds.Close()

	filespace := ds.Space()
	defer filespace.Close()

	shp := conv.IntsToUints(data.Shape())
	stride_count := conv.IntsToUints(slice.Ones(len(loc)))
	err = filespace.SelectHyperslab(conv.IntsToUints(loc), stride_count, stride_count, shp)
	if err != nil {
		return err
	}

	memSpace, err := hdf5.CreateSimpleDataspace(shp, shp)
	if err != nil {
		return err
	}
	defer memSpace.Close()

	impl := data.Unroll()
	err = ds.WriteSubset(&impl, memSpace, filespace)

	return nil
}

func (h H5RefInt32) LoadText() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	dt, err := ds.Datatype()
	defer dt.Close()

	if dt.GoType() != reflect.TypeOf("a string") {
		return nil, errors.New("Not a string type")
	}

	space := ds.Space()
	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	if len(dims) > 1 {
		return nil, errors.New("Can only read 1D data as text")
	}
	maxLen := int(dt.Size())
	nStrings := int(dims[0])
	characters := make([]byte, nStrings*maxLen)
	ds.Read(&characters)

	result := make([]string, dims[0])
	for i := 0; i < nStrings; i++ {
		theBytes := characters[(i * maxLen):((i + 1) * maxLen)]
		end := bytes.Index(theBytes, []byte{0})
		if end < 0 {
			end = maxLen
		}
		theBytes = theBytes[0:end]
		result[i] = string(theBytes)
	}
	return result, nil
}

func (h H5RefInt32) GetDatasets() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_DATASET {
			result = append(result, name)
		}
	}
	return result, nil
}

func (h H5RefInt32) GetGroups() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_GROUP {
			result = append(result, name)
		}
	}
	return result, nil
}

func ParseH5RefInt32(path string) H5RefInt32 {
	components := strings.Split(path, ":")
	return H5RefInt32{components[0], components[1], nil}
}

func (h H5RefInt32) Exists() bool {
	components := strings.Split(h.Dataset, "/")

	path := "/"
	for ix, comp := range components {
		ref := H5RefInt32{Filename: h.Filename, Dataset: path}

		if ix == (len(components) - 1) {
			datasets, err := ref.GetDatasets()

			if err != nil {
				return false
			}
			if findInSlice(datasets, comp) >= 0 {
				return true
			}
		}

		groups, err := ref.GetGroups()

		if err != nil {
			return false
		}
		if findInSlice(groups, comp) < 0 {
			return false
		}

		path = fmt.Sprintf("%s/%s", path, comp)
	}

	return true
}

func (h H5RefInt32) Shape() ([]int, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	return shape, nil
}

type H5RefUint32 struct {
	Filename string
	Dataset  string
	Slice    [][]int
}

func (h H5RefUint32) Load() (data.NDUint32, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)
	// mu.RLock()
	// defer mu.RUnlock()

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	if h.Slice != nil {
		for _, s := range h.Slice {
			if s != nil {
				return h.loadSubset(ds)
			}
		}
	}

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	result := data.NewArrayUint32(shape)
	impl := result.Unroll()
	ds.Read(&impl)
	return result, nil
}

func (h H5RefUint32) loadSubset(ds *hdf5.Dataset) (data.NDUint32, error) {
	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}
	shape := conv.UintsToInts(dims)

	offset, stride, count, block := makeHyperslab(h.Slice, shape)
	filespace := space
	err = filespace.SelectHyperslab(offset, stride, count, block)
	if err != nil {
		return nil, err
	}

	for dim, size := range shape {
		if h.Slice[dim] != nil {
			newSize := sliceSize(h.Slice[dim], size)
			shape[dim] = newSize
		}
	}
	ushape := conv.IntsToUints(shape)
	memSpace, err := hdf5.CreateSimpleDataspace(ushape, ushape)
	if err != nil {
		return nil, err
	}
	defer memSpace.Close()

	result := data.NewArrayUint32(shape)
	impl := result.Unroll()
	err = ds.ReadSubset(&impl, memSpace, filespace)
	return result, err
}

func (h H5RefUint32) Write(data data.NDUint32) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)
	// mu.Lock()
	// defer mu.Unlock()
	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, data.Shape(), data.Get(data.NewIndex(0)), false)
	if err != nil {
		return err
	}
	defer ds.Close()

	arrAsSlice := data.Unroll()
	err = ds.Write(&arrAsSlice)
	if err != nil {
		return err
	}

	return nil
}

func (h H5RefUint32) Create(shape []int, fillValue uint32, compress bool) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, shape, fillValue, compress)
	if err == nil {
		ds.Close()
	}
	return err
}

func (h H5RefUint32) WriteSlice(data data.NDUint32, loc []int) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, false)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return err
	}
	defer ds.Close()

	filespace := ds.Space()
	defer filespace.Close()

	shp := conv.IntsToUints(data.Shape())
	stride_count := conv.IntsToUints(slice.Ones(len(loc)))
	err = filespace.SelectHyperslab(conv.IntsToUints(loc), stride_count, stride_count, shp)
	if err != nil {
		return err
	}

	memSpace, err := hdf5.CreateSimpleDataspace(shp, shp)
	if err != nil {
		return err
	}
	defer memSpace.Close()

	impl := data.Unroll()
	err = ds.WriteSubset(&impl, memSpace, filespace)

	return nil
}

func (h H5RefUint32) LoadText() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	dt, err := ds.Datatype()
	defer dt.Close()

	if dt.GoType() != reflect.TypeOf("a string") {
		return nil, errors.New("Not a string type")
	}

	space := ds.Space()
	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	if len(dims) > 1 {
		return nil, errors.New("Can only read 1D data as text")
	}
	maxLen := int(dt.Size())
	nStrings := int(dims[0])
	characters := make([]byte, nStrings*maxLen)
	ds.Read(&characters)

	result := make([]string, dims[0])
	for i := 0; i < nStrings; i++ {
		theBytes := characters[(i * maxLen):((i + 1) * maxLen)]
		end := bytes.Index(theBytes, []byte{0})
		if end < 0 {
			end = maxLen
		}
		theBytes = theBytes[0:end]
		result[i] = string(theBytes)
	}
	return result, nil
}

func (h H5RefUint32) GetDatasets() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_DATASET {
			result = append(result, name)
		}
	}
	return result, nil
}

func (h H5RefUint32) GetGroups() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_GROUP {
			result = append(result, name)
		}
	}
	return result, nil
}

func ParseH5RefUint32(path string) H5RefUint32 {
	components := strings.Split(path, ":")
	return H5RefUint32{components[0], components[1], nil}
}

func (h H5RefUint32) Exists() bool {
	components := strings.Split(h.Dataset, "/")

	path := "/"
	for ix, comp := range components {
		ref := H5RefUint32{Filename: h.Filename, Dataset: path}

		if ix == (len(components) - 1) {
			datasets, err := ref.GetDatasets()

			if err != nil {
				return false
			}
			if findInSlice(datasets, comp) >= 0 {
				return true
			}
		}

		groups, err := ref.GetGroups()

		if err != nil {
			return false
		}
		if findInSlice(groups, comp) < 0 {
			return false
		}

		path = fmt.Sprintf("%s/%s", path, comp)
	}

	return true
}

func (h H5RefUint32) Shape() ([]int, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	return shape, nil
}

type H5RefInt64 struct {
	Filename string
	Dataset  string
	Slice    [][]int
}

func (h H5RefInt64) Load() (data.NDInt64, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)
	// mu.RLock()
	// defer mu.RUnlock()

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	if h.Slice != nil {
		for _, s := range h.Slice {
			if s != nil {
				return h.loadSubset(ds)
			}
		}
	}

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	result := data.NewArrayInt64(shape)
	impl := result.Unroll()
	ds.Read(&impl)
	return result, nil
}

func (h H5RefInt64) loadSubset(ds *hdf5.Dataset) (data.NDInt64, error) {
	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}
	shape := conv.UintsToInts(dims)

	offset, stride, count, block := makeHyperslab(h.Slice, shape)
	filespace := space
	err = filespace.SelectHyperslab(offset, stride, count, block)
	if err != nil {
		return nil, err
	}

	for dim, size := range shape {
		if h.Slice[dim] != nil {
			newSize := sliceSize(h.Slice[dim], size)
			shape[dim] = newSize
		}
	}
	ushape := conv.IntsToUints(shape)
	memSpace, err := hdf5.CreateSimpleDataspace(ushape, ushape)
	if err != nil {
		return nil, err
	}
	defer memSpace.Close()

	result := data.NewArrayInt64(shape)
	impl := result.Unroll()
	err = ds.ReadSubset(&impl, memSpace, filespace)
	return result, err
}

func (h H5RefInt64) Write(data data.NDInt64) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)
	// mu.Lock()
	// defer mu.Unlock()
	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, data.Shape(), data.Get(data.NewIndex(0)), false)
	if err != nil {
		return err
	}
	defer ds.Close()

	arrAsSlice := data.Unroll()
	err = ds.Write(&arrAsSlice)
	if err != nil {
		return err
	}

	return nil
}

func (h H5RefInt64) Create(shape []int, fillValue int64, compress bool) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, shape, fillValue, compress)
	if err == nil {
		ds.Close()
	}
	return err
}

func (h H5RefInt64) WriteSlice(data data.NDInt64, loc []int) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, false)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return err
	}
	defer ds.Close()

	filespace := ds.Space()
	defer filespace.Close()

	shp := conv.IntsToUints(data.Shape())
	stride_count := conv.IntsToUints(slice.Ones(len(loc)))
	err = filespace.SelectHyperslab(conv.IntsToUints(loc), stride_count, stride_count, shp)
	if err != nil {
		return err
	}

	memSpace, err := hdf5.CreateSimpleDataspace(shp, shp)
	if err != nil {
		return err
	}
	defer memSpace.Close()

	impl := data.Unroll()
	err = ds.WriteSubset(&impl, memSpace, filespace)

	return nil
}

func (h H5RefInt64) LoadText() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	dt, err := ds.Datatype()
	defer dt.Close()

	if dt.GoType() != reflect.TypeOf("a string") {
		return nil, errors.New("Not a string type")
	}

	space := ds.Space()
	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	if len(dims) > 1 {
		return nil, errors.New("Can only read 1D data as text")
	}
	maxLen := int(dt.Size())
	nStrings := int(dims[0])
	characters := make([]byte, nStrings*maxLen)
	ds.Read(&characters)

	result := make([]string, dims[0])
	for i := 0; i < nStrings; i++ {
		theBytes := characters[(i * maxLen):((i + 1) * maxLen)]
		end := bytes.Index(theBytes, []byte{0})
		if end < 0 {
			end = maxLen
		}
		theBytes = theBytes[0:end]
		result[i] = string(theBytes)
	}
	return result, nil
}

func (h H5RefInt64) GetDatasets() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_DATASET {
			result = append(result, name)
		}
	}
	return result, nil
}

func (h H5RefInt64) GetGroups() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_GROUP {
			result = append(result, name)
		}
	}
	return result, nil
}

func ParseH5RefInt64(path string) H5RefInt64 {
	components := strings.Split(path, ":")
	return H5RefInt64{components[0], components[1], nil}
}

func (h H5RefInt64) Exists() bool {
	components := strings.Split(h.Dataset, "/")

	path := "/"
	for ix, comp := range components {
		ref := H5RefInt64{Filename: h.Filename, Dataset: path}

		if ix == (len(components) - 1) {
			datasets, err := ref.GetDatasets()

			if err != nil {
				return false
			}
			if findInSlice(datasets, comp) >= 0 {
				return true
			}
		}

		groups, err := ref.GetGroups()

		if err != nil {
			return false
		}
		if findInSlice(groups, comp) < 0 {
			return false
		}

		path = fmt.Sprintf("%s/%s", path, comp)
	}

	return true
}

func (h H5RefInt64) Shape() ([]int, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	return shape, nil
}

type H5RefUint64 struct {
	Filename string
	Dataset  string
	Slice    [][]int
}

func (h H5RefUint64) Load() (data.NDUint64, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)
	// mu.RLock()
	// defer mu.RUnlock()

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	if h.Slice != nil {
		for _, s := range h.Slice {
			if s != nil {
				return h.loadSubset(ds)
			}
		}
	}

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	result := data.NewArrayUint64(shape)
	impl := result.Unroll()
	ds.Read(&impl)
	return result, nil
}

func (h H5RefUint64) loadSubset(ds *hdf5.Dataset) (data.NDUint64, error) {
	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}
	shape := conv.UintsToInts(dims)

	offset, stride, count, block := makeHyperslab(h.Slice, shape)
	filespace := space
	err = filespace.SelectHyperslab(offset, stride, count, block)
	if err != nil {
		return nil, err
	}

	for dim, size := range shape {
		if h.Slice[dim] != nil {
			newSize := sliceSize(h.Slice[dim], size)
			shape[dim] = newSize
		}
	}
	ushape := conv.IntsToUints(shape)
	memSpace, err := hdf5.CreateSimpleDataspace(ushape, ushape)
	if err != nil {
		return nil, err
	}
	defer memSpace.Close()

	result := data.NewArrayUint64(shape)
	impl := result.Unroll()
	err = ds.ReadSubset(&impl, memSpace, filespace)
	return result, err
}

func (h H5RefUint64) Write(data data.NDUint64) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)
	// mu.Lock()
	// defer mu.Unlock()
	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, data.Shape(), data.Get(data.NewIndex(0)), false)
	if err != nil {
		return err
	}
	defer ds.Close()

	arrAsSlice := data.Unroll()
	err = ds.Write(&arrAsSlice)
	if err != nil {
		return err
	}

	return nil
}

func (h H5RefUint64) Create(shape []int, fillValue uint64, compress bool) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, shape, fillValue, compress)
	if err == nil {
		ds.Close()
	}
	return err
}

func (h H5RefUint64) WriteSlice(data data.NDUint64, loc []int) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, false)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return err
	}
	defer ds.Close()

	filespace := ds.Space()
	defer filespace.Close()

	shp := conv.IntsToUints(data.Shape())
	stride_count := conv.IntsToUints(slice.Ones(len(loc)))
	err = filespace.SelectHyperslab(conv.IntsToUints(loc), stride_count, stride_count, shp)
	if err != nil {
		return err
	}

	memSpace, err := hdf5.CreateSimpleDataspace(shp, shp)
	if err != nil {
		return err
	}
	defer memSpace.Close()

	impl := data.Unroll()
	err = ds.WriteSubset(&impl, memSpace, filespace)

	return nil
}

func (h H5RefUint64) LoadText() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	dt, err := ds.Datatype()
	defer dt.Close()

	if dt.GoType() != reflect.TypeOf("a string") {
		return nil, errors.New("Not a string type")
	}

	space := ds.Space()
	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	if len(dims) > 1 {
		return nil, errors.New("Can only read 1D data as text")
	}
	maxLen := int(dt.Size())
	nStrings := int(dims[0])
	characters := make([]byte, nStrings*maxLen)
	ds.Read(&characters)

	result := make([]string, dims[0])
	for i := 0; i < nStrings; i++ {
		theBytes := characters[(i * maxLen):((i + 1) * maxLen)]
		end := bytes.Index(theBytes, []byte{0})
		if end < 0 {
			end = maxLen
		}
		theBytes = theBytes[0:end]
		result[i] = string(theBytes)
	}
	return result, nil
}

func (h H5RefUint64) GetDatasets() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_DATASET {
			result = append(result, name)
		}
	}
	return result, nil
}

func (h H5RefUint64) GetGroups() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_GROUP {
			result = append(result, name)
		}
	}
	return result, nil
}

func ParseH5RefUint64(path string) H5RefUint64 {
	components := strings.Split(path, ":")
	return H5RefUint64{components[0], components[1], nil}
}

func (h H5RefUint64) Exists() bool {
	components := strings.Split(h.Dataset, "/")

	path := "/"
	for ix, comp := range components {
		ref := H5RefUint64{Filename: h.Filename, Dataset: path}

		if ix == (len(components) - 1) {
			datasets, err := ref.GetDatasets()

			if err != nil {
				return false
			}
			if findInSlice(datasets, comp) >= 0 {
				return true
			}
		}

		groups, err := ref.GetGroups()

		if err != nil {
			return false
		}
		if findInSlice(groups, comp) < 0 {
			return false
		}

		path = fmt.Sprintf("%s/%s", path, comp)
	}

	return true
}

func (h H5RefUint64) Shape() ([]int, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	return shape, nil
}

type H5RefInt struct {
	Filename string
	Dataset  string
	Slice    [][]int
}

func (h H5RefInt) Load() (data.NDInt, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)
	// mu.RLock()
	// defer mu.RUnlock()

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	if h.Slice != nil {
		for _, s := range h.Slice {
			if s != nil {
				return h.loadSubset(ds)
			}
		}
	}

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	result := data.NewArrayInt(shape)
	impl := result.Unroll()
	ds.Read(&impl)
	return result, nil
}

func (h H5RefInt) loadSubset(ds *hdf5.Dataset) (data.NDInt, error) {
	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}
	shape := conv.UintsToInts(dims)

	offset, stride, count, block := makeHyperslab(h.Slice, shape)
	filespace := space
	err = filespace.SelectHyperslab(offset, stride, count, block)
	if err != nil {
		return nil, err
	}

	for dim, size := range shape {
		if h.Slice[dim] != nil {
			newSize := sliceSize(h.Slice[dim], size)
			shape[dim] = newSize
		}
	}
	ushape := conv.IntsToUints(shape)
	memSpace, err := hdf5.CreateSimpleDataspace(ushape, ushape)
	if err != nil {
		return nil, err
	}
	defer memSpace.Close()

	result := data.NewArrayInt(shape)
	impl := result.Unroll()
	err = ds.ReadSubset(&impl, memSpace, filespace)
	return result, err
}

func (h H5RefInt) Write(data data.NDInt) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)
	// mu.Lock()
	// defer mu.Unlock()
	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, data.Shape(), data.Get(data.NewIndex(0)), false)
	if err != nil {
		return err
	}
	defer ds.Close()

	arrAsSlice := data.Unroll()
	err = ds.Write(&arrAsSlice)
	if err != nil {
		return err
	}

	return nil
}

func (h H5RefInt) Create(shape []int, fillValue int, compress bool) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, shape, fillValue, compress)
	if err == nil {
		ds.Close()
	}
	return err
}

func (h H5RefInt) WriteSlice(data data.NDInt, loc []int) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, false)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return err
	}
	defer ds.Close()

	filespace := ds.Space()
	defer filespace.Close()

	shp := conv.IntsToUints(data.Shape())
	stride_count := conv.IntsToUints(slice.Ones(len(loc)))
	err = filespace.SelectHyperslab(conv.IntsToUints(loc), stride_count, stride_count, shp)
	if err != nil {
		return err
	}

	memSpace, err := hdf5.CreateSimpleDataspace(shp, shp)
	if err != nil {
		return err
	}
	defer memSpace.Close()

	impl := data.Unroll()
	err = ds.WriteSubset(&impl, memSpace, filespace)

	return nil
}

func (h H5RefInt) LoadText() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	dt, err := ds.Datatype()
	defer dt.Close()

	if dt.GoType() != reflect.TypeOf("a string") {
		return nil, errors.New("Not a string type")
	}

	space := ds.Space()
	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	if len(dims) > 1 {
		return nil, errors.New("Can only read 1D data as text")
	}
	maxLen := int(dt.Size())
	nStrings := int(dims[0])
	characters := make([]byte, nStrings*maxLen)
	ds.Read(&characters)

	result := make([]string, dims[0])
	for i := 0; i < nStrings; i++ {
		theBytes := characters[(i * maxLen):((i + 1) * maxLen)]
		end := bytes.Index(theBytes, []byte{0})
		if end < 0 {
			end = maxLen
		}
		theBytes = theBytes[0:end]
		result[i] = string(theBytes)
	}
	return result, nil
}

func (h H5RefInt) GetDatasets() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_DATASET {
			result = append(result, name)
		}
	}
	return result, nil
}

func (h H5RefInt) GetGroups() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_GROUP {
			result = append(result, name)
		}
	}
	return result, nil
}

func ParseH5RefInt(path string) H5RefInt {
	components := strings.Split(path, ":")
	return H5RefInt{components[0], components[1], nil}
}

func (h H5RefInt) Exists() bool {
	components := strings.Split(h.Dataset, "/")

	path := "/"
	for ix, comp := range components {
		ref := H5RefInt{Filename: h.Filename, Dataset: path}

		if ix == (len(components) - 1) {
			datasets, err := ref.GetDatasets()

			if err != nil {
				return false
			}
			if findInSlice(datasets, comp) >= 0 {
				return true
			}
		}

		groups, err := ref.GetGroups()

		if err != nil {
			return false
		}
		if findInSlice(groups, comp) < 0 {
			return false
		}

		path = fmt.Sprintf("%s/%s", path, comp)
	}

	return true
}

func (h H5RefInt) Shape() ([]int, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	return shape, nil
}

type H5RefUint struct {
	Filename string
	Dataset  string
	Slice    [][]int
}

func (h H5RefUint) Load() (data.NDUint, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)
	// mu.RLock()
	// defer mu.RUnlock()

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	if h.Slice != nil {
		for _, s := range h.Slice {
			if s != nil {
				return h.loadSubset(ds)
			}
		}
	}

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	result := data.NewArrayUint(shape)
	impl := result.Unroll()
	ds.Read(&impl)
	return result, nil
}

func (h H5RefUint) loadSubset(ds *hdf5.Dataset) (data.NDUint, error) {
	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}
	shape := conv.UintsToInts(dims)

	offset, stride, count, block := makeHyperslab(h.Slice, shape)
	filespace := space
	err = filespace.SelectHyperslab(offset, stride, count, block)
	if err != nil {
		return nil, err
	}

	for dim, size := range shape {
		if h.Slice[dim] != nil {
			newSize := sliceSize(h.Slice[dim], size)
			shape[dim] = newSize
		}
	}
	ushape := conv.IntsToUints(shape)
	memSpace, err := hdf5.CreateSimpleDataspace(ushape, ushape)
	if err != nil {
		return nil, err
	}
	defer memSpace.Close()

	result := data.NewArrayUint(shape)
	impl := result.Unroll()
	err = ds.ReadSubset(&impl, memSpace, filespace)
	return result, err
}

func (h H5RefUint) Write(data data.NDUint) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)
	// mu.Lock()
	// defer mu.Unlock()
	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, data.Shape(), data.Get(data.NewIndex(0)), false)
	if err != nil {
		return err
	}
	defer ds.Close()

	arrAsSlice := data.Unroll()
	err = ds.Write(&arrAsSlice)
	if err != nil {
		return err
	}

	return nil
}

func (h H5RefUint) Create(shape []int, fillValue uint, compress bool) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, true)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := openOrCreateDataset(f, h.Dataset, shape, fillValue, compress)
	if err == nil {
		ds.Close()
	}
	return err
}

func (h H5RefUint) WriteSlice(data data.NDUint, loc []int) error {
	lockHDF5(h.Filename)
	defer unlockHDF5(h.Filename)

	f, err := openWriteOrCreate(h.Filename, false)
	if err != nil {
		return err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return err
	}
	defer ds.Close()

	filespace := ds.Space()
	defer filespace.Close()

	shp := conv.IntsToUints(data.Shape())
	stride_count := conv.IntsToUints(slice.Ones(len(loc)))
	err = filespace.SelectHyperslab(conv.IntsToUints(loc), stride_count, stride_count, shp)
	if err != nil {
		return err
	}

	memSpace, err := hdf5.CreateSimpleDataspace(shp, shp)
	if err != nil {
		return err
	}
	defer memSpace.Close()

	impl := data.Unroll()
	err = ds.WriteSubset(&impl, memSpace, filespace)

	return nil
}

func (h H5RefUint) LoadText() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	dt, err := ds.Datatype()
	defer dt.Close()

	if dt.GoType() != reflect.TypeOf("a string") {
		return nil, errors.New("Not a string type")
	}

	space := ds.Space()
	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	if len(dims) > 1 {
		return nil, errors.New("Can only read 1D data as text")
	}
	maxLen := int(dt.Size())
	nStrings := int(dims[0])
	characters := make([]byte, nStrings*maxLen)
	ds.Read(&characters)

	result := make([]string, dims[0])
	for i := 0; i < nStrings; i++ {
		theBytes := characters[(i * maxLen):((i + 1) * maxLen)]
		end := bytes.Index(theBytes, []byte{0})
		if end < 0 {
			end = maxLen
		}
		theBytes = theBytes[0:end]
		result[i] = string(theBytes)
	}
	return result, nil
}

func (h H5RefUint) GetDatasets() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_DATASET {
			result = append(result, name)
		}
	}
	return result, nil
}

func (h H5RefUint) GetGroups() ([]string, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	g, err := f.OpenGroup(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer g.Close()

	n, err := g.NumObjects()
	if err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for i := 0; i < int(n); i++ {
		name, err := g.ObjectNameByIndex(uint(i))
		if err != nil {
			return nil, err
		}

		objType, err := g.ObjectTypeByIndex(uint(i))
		if err == nil && objType == hdf5.H5G_GROUP {
			result = append(result, name)
		}
	}
	return result, nil
}

func ParseH5RefUint(path string) H5RefUint {
	components := strings.Split(path, ":")
	return H5RefUint{components[0], components[1], nil}
}

func (h H5RefUint) Exists() bool {
	components := strings.Split(h.Dataset, "/")

	path := "/"
	for ix, comp := range components {
		ref := H5RefUint{Filename: h.Filename, Dataset: path}

		if ix == (len(components) - 1) {
			datasets, err := ref.GetDatasets()

			if err != nil {
				return false
			}
			if findInSlice(datasets, comp) >= 0 {
				return true
			}
		}

		groups, err := ref.GetGroups()

		if err != nil {
			return false
		}
		if findInSlice(groups, comp) < 0 {
			return false
		}

		path = fmt.Sprintf("%s/%s", path, comp)
	}

	return true
}

func (h H5RefUint) Shape() ([]int, error) {
	rLockHDF5(h.Filename)
	defer rUnlockHDF5(h.Filename)

	f, err := hdf5.OpenFile(h.Filename, hdf5.F_ACC_RDONLY)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	ds, err := f.OpenDataset(h.Dataset)
	if err != nil {
		return nil, err
	}
	defer ds.Close()

	space := ds.Space()
	defer space.Close()

	dims, _, err := space.SimpleExtentDims()
	if err != nil {
		return nil, err
	}

	shape := conv.UintsToInts(dims)
	return shape, nil
}
