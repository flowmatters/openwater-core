package rr

/* WARNING: GENERATED CODE
 *
 * This file is generated by ow-specgen using metadata from ./models/rr/sacramento.go
 * 
 * Don't edit this file. Edit ./models/rr/sacramento.go instead!
 */
import (
//  "fmt"
  "github.com/flowmatters/openwater-core/sim"
  "github.com/flowmatters/openwater-core/data"
)


type Sacramento struct {
  lzpk data.ND1Float64
  lzsk data.ND1Float64
  uzk data.ND1Float64
  uztwm data.ND1Float64
  uzfwm data.ND1Float64
  lztwm data.ND1Float64
  lzfsm data.ND1Float64
  lzfpm data.ND1Float64
  pfree data.ND1Float64
  rexp data.ND1Float64
  zperc data.ND1Float64
  side data.ND1Float64
  ssout data.ND1Float64
  pctim data.ND1Float64
  adimp data.ND1Float64
  sarva data.ND1Float64
  rserv data.ND1Float64
  uh1 data.ND1Float64
  uh2 data.ND1Float64
  uh3 data.ND1Float64
  uh4 data.ND1Float64
  uh5 data.ND1Float64
  

  
}

func (m *Sacramento) ApplyParameters(parameters data.ND2Float64) {

  nSets := parameters.Len(sim.DIMP_CELL)
  var newShape []int
  paramIdx := 0
  paramSize := 1


  paramSize = 1
  newShape = []int{ nSets}

  m.lzpk = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.lzsk = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.uzk = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.uztwm = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.uzfwm = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.lztwm = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.lzfsm = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.lzfpm = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.pfree = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.rexp = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.zperc = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.side = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.ssout = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.pctim = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.adimp = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.sarva = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.rserv = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.uh1 = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.uh2 = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.uh3 = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.uh4 = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.uh5 = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  
}


func buildSacramento() sim.TimeSteppingModel {
	result := Sacramento{}
	return &result
}

func init() {
	sim.Catalog["Sacramento"] = buildSacramento
}

func (m *Sacramento)  Description() sim.ModelDescription{
	var result sim.ModelDescription
  
  lzpkDims := []string{
      }
  
  lzskDims := []string{
      }
  
  uzkDims := []string{
      }
  
  uztwmDims := []string{
      }
  
  uzfwmDims := []string{
      }
  
  lztwmDims := []string{
      }
  
  lzfsmDims := []string{
      }
  
  lzfpmDims := []string{
      }
  
  pfreeDims := []string{
      }
  
  rexpDims := []string{
      }
  
  zpercDims := []string{
      }
  
  sideDims := []string{
      }
  
  ssoutDims := []string{
      }
  
  pctimDims := []string{
      }
  
  adimpDims := []string{
      }
  
  sarvaDims := []string{
      }
  
  rservDims := []string{
      }
  
  uh1Dims := []string{
      }
  
  uh2Dims := []string{
      }
  
  uh3Dims := []string{
      }
  
  uh4Dims := []string{
      }
  
  uh5Dims := []string{
      }
  
	result.Parameters = []sim.ParameterDescription{
  
  sim.DescribeParameter("lzpk",0.01,"Lower zone Primary Free water base flow ratio",[]float64{ 0, 1 }," ",lzpkDims),
  sim.DescribeParameter("lzsk",0.05,"Lower zone Supplementary Free water base flow ratio",[]float64{ 0, 1 }," ",lzskDims),
  sim.DescribeParameter("uzk",0.3,"Upper zone free water interflow fraction",[]float64{ 0, 1 }," ",uzkDims),
  sim.DescribeParameter("uztwm",50,"mm Upper zone tension water maximum",[]float64{ 0.1, 125 },"",uztwmDims),
  sim.DescribeParameter("uzfwm",40,"mm Upper zone free water maximum",[]float64{ 0, 75 },"",uzfwmDims),
  sim.DescribeParameter("lztwm",130,"mm Lower zone tension water maximum",[]float64{ 0, 300 },"",lztwmDims),
  sim.DescribeParameter("lzfsm",25,"mm Lower zone free water supplemental maximum",[]float64{ 0, 300 },"",lzfsmDims),
  sim.DescribeParameter("lzfpm",60,"mm Lower zone free water primary maximum",[]float64{ 0, 600 },"",lzfpmDims),
  sim.DescribeParameter("pfree",0.06,"Minimum proportion of percolation from upper zone to lower zone directly available for recharing lower zone free water stores.",[]float64{ 0, 1 }," ",pfreeDims),
  sim.DescribeParameter("rexp",1,"Exponent of rate of change of percolation rate with changing LZ storage",[]float64{ 0, 3 }," ",rexpDims),
  sim.DescribeParameter("zperc",40,"Proportional increase in Pbase defining maximum percolation rate",[]float64{ 0, 80 }," ",zpercDims),
  sim.DescribeParameter("side",0,"Ratio of non-channel baseflow to channel baseflow",[]float64{ 0, 1 }," ",sideDims),
  sim.DescribeParameter("ssout",0,"[0",[]float64{ 0, 0 },"",ssoutDims),
  sim.DescribeParameter("pctim",0.01,"fraction of catchment that is permanently and directly connected impervious",[]float64{ 0, 1 }," ",pctimDims),
  sim.DescribeParameter("adimp",0,"additional fraction of catchment that can act impervious under saturated soil conditions.",[]float64{ 0, 1 }," ",adimpDims),
  sim.DescribeParameter("sarva",0,"fraction of basin normally covered by streams",[]float64{ 0, 1 }," ",sarvaDims),
  sim.DescribeParameter("rserv",0.3,"Fraction lower zone free water that is not available for transpiration",[]float64{ 0, 1 }," ",rservDims),
  sim.DescribeParameter("uh1",0.8,"Unit hydrograph - proportion runoff that is instantaneous",[]float64{ 0, 1 }," ",uh1Dims),
  sim.DescribeParameter("uh2",0.1,"Unit hydrograph - proportion lagged by one timestep",[]float64{ 0, 1 }," ",uh2Dims),
  sim.DescribeParameter("uh3",0.05,"Unit hydrograph - proportion lagged by two timesteps",[]float64{ 0, 1 }," ",uh3Dims),
  sim.DescribeParameter("uh4",0.03,"Unit hydrograph - proportion lagged by three timesteps",[]float64{ 0, 1 }," ",uh4Dims),
  sim.DescribeParameter("uh5",0.02,"Unit hydrograph - proportion lagged by four timesteps",[]float64{ 0, 1 }," ",uh5Dims),}

  result.Inputs = []string{
  "rainfall","pet",}
  result.Outputs = []string{
  "actualET","runoff","imperviousRunoff","surfaceRunoff","baseflow",}

  result.States = []string{
  "UprTensionWater","UprFreeWater","LwrTensionWater","LwrPrimaryFreeWater","LwrSupplFreeWater","AdditionalImperviousStore",}

  result.Dimensions = []string{
      }
	return result
}

func (m *Sacramento) InitialiseDimensions(dims []int) {
  
}

func (m *Sacramento) FindDimensions(parameters data.ND2Float64) []int {
  
  return []int{}
  
}




func (m *Sacramento) InitialiseStates(n int) data.ND2Float64 {
  // Zero states
	var result = data.NewArray2DFloat64(n,6)

	// for i := 0; i < n; i++ {
  //   stateSet := make(sim.StateSet,6)
  //   
	// 	stateSet[0] = 0 // UprTensionWater
  //   
	// 	stateSet[1] = 0 // UprFreeWater
  //   
	// 	stateSet[2] = 0 // LwrTensionWater
  //   
	// 	stateSet[3] = 0 // LwrPrimaryFreeWater
  //   
	// 	stateSet[4] = 0 // LwrSupplFreeWater
  //   
	// 	stateSet[5] = 0 // AdditionalImperviousStore
  //   

  //   if result==nil {
  //     result = data.NewArray2DFloat64(stateSet.Len(0),n)
  //   }
  //   result.Apply([]int{0,i},[]int{1,1},stateSet)
	// }
 
	return result
}



func (m *Sacramento) Run(inputs data.ND3Float64, states data.ND2Float64, outputs data.ND3Float64) {

  // Loop over all cells
  inputDims := inputs.Shape()
  numCells := states.Len(sim.DIMS_CELL)
  numStates := states.Len(sim.DIMS_STATE)
  numInputSequences := inputs.Len(sim.DIMI_CELL)

  //  fmt.Println("num cells",lenStates,"num states",numStates)
  // fmt.Println("states shape",states.Shape())
  // fmt.Println("states",states) 
  inputLen := inputDims[sim.DIMI_TIMESTEP]
  cellInputsShape := inputDims[1:]
  inputNewShape := []int{inputLen}

//  outputPosSlice := outputs.NewIndex(0)
  outputStepSlice := outputs.NewIndex(1)
  outputSizeSlice := outputs.NewIndex(1)
  outputSizeSlice[sim.DIMO_TIMESTEP] = inputLen

//  statesPosSlice := states.NewIndex(0)
  statesSizeSlice := states.NewIndex(1)
  statesSizeSlice[sim.DIMS_STATE] = numStates

//  inputsPosSlice := inputs.NewIndex(0)
  inputsSizeSlice := inputs.NewIndex(1)
  inputsSizeSlice[sim.DIMI_INPUT] = inputDims[sim.DIMI_INPUT]
  inputsSizeSlice[sim.DIMI_TIMESTEP] = inputLen

//  var result sim.RunResults
//	result.Outputs = data.NewArray3DFloat64( 5, inputLen, numCells)
//	result.States = states  //clone? make([]sim.StateSet, len(states))

  doneChan := make(chan int)
  // fmt.Println("Running Sacramento for ",numCells,"cells")
//  for i := 0; i < numCells; i++ {
  for j := 0; j < numCells; j++ {
    go func(i int){
      outputPosSlice := outputs.NewIndex(0)
      statesPosSlice := states.NewIndex(0)
      inputsPosSlice := inputs.NewIndex(0)

      outputPosSlice[sim.DIMO_CELL] = i
      statesPosSlice[sim.DIMS_CELL] = i
      inputsPosSlice[sim.DIMI_CELL] = i%numInputSequences

      lzpk := m.lzpk.Get1(i%m.lzpk.Len1())
      lzsk := m.lzsk.Get1(i%m.lzsk.Len1())
      uzk := m.uzk.Get1(i%m.uzk.Len1())
      uztwm := m.uztwm.Get1(i%m.uztwm.Len1())
      uzfwm := m.uzfwm.Get1(i%m.uzfwm.Len1())
      lztwm := m.lztwm.Get1(i%m.lztwm.Len1())
      lzfsm := m.lzfsm.Get1(i%m.lzfsm.Len1())
      lzfpm := m.lzfpm.Get1(i%m.lzfpm.Len1())
      pfree := m.pfree.Get1(i%m.pfree.Len1())
      rexp := m.rexp.Get1(i%m.rexp.Len1())
      zperc := m.zperc.Get1(i%m.zperc.Len1())
      side := m.side.Get1(i%m.side.Len1())
      ssout := m.ssout.Get1(i%m.ssout.Len1())
      pctim := m.pctim.Get1(i%m.pctim.Len1())
      adimp := m.adimp.Get1(i%m.adimp.Len1())
      sarva := m.sarva.Get1(i%m.sarva.Len1())
      rserv := m.rserv.Get1(i%m.rserv.Len1())
      uh1 := m.uh1.Get1(i%m.uh1.Len1())
      uh2 := m.uh2.Get1(i%m.uh2.Len1())
      uh3 := m.uh3.Get1(i%m.uh3.Len1())
      uh4 := m.uh4.Get1(i%m.uh4.Len1())
      uh5 := m.uh5.Get1(i%m.uh5.Len1())
      

      // fmt.Println("i",i)
      // fmt.Println("States",states.Shape())
      // fmt.Println("Tmp2",tmp2.Shape())
      
      initialStates := states.Slice(statesPosSlice,statesSizeSlice,nil).MustReshape([]int{numStates}).(data.ND1Float64)
      

      
      
      uprtensionwater := initialStates.Get1(0)
      
      uprfreewater := initialStates.Get1(1)
      
      lwrtensionwater := initialStates.Get1(2)
      
      lwrprimaryfreewater := initialStates.Get1(3)
      
      lwrsupplfreewater := initialStates.Get1(4)
      
      additionalimperviousstore := initialStates.Get1(5)
      
      

  //    fmt.Println("is",inputDims,"tmpShape",tmpCI.Shape(),"cis",cellInputsShape)

      cellInputs := inputs.Slice(inputsPosSlice,inputsSizeSlice,nil).MustReshape(cellInputsShape)
  //    fmt.Println("cellInputs Shape",cellInputs.Shape())
      
  //    fmt.Println("{rainfall mm}",tmpTS.Shape())
      rainfall := cellInputs.Slice([]int{ 0,0}, []int{ 1,inputLen}, nil).MustReshape(inputNewShape).(data.ND1Float64)
      
  //    fmt.Println("{pet mm}",tmpTS.Shape())
      pet := cellInputs.Slice([]int{ 1,0}, []int{ 1,inputLen}, nil).MustReshape(inputNewShape).(data.ND1Float64)
      

      

      
      
      outputPosSlice[sim.DIMO_OUTPUT] = 0
      actualet := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
      
      outputPosSlice[sim.DIMO_OUTPUT] = 1
      runoff := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
      
      outputPosSlice[sim.DIMO_OUTPUT] = 2
      imperviousrunoff := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
      
      outputPosSlice[sim.DIMO_OUTPUT] = 3
      surfacerunoff := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
      
      outputPosSlice[sim.DIMO_OUTPUT] = 4
      baseflow := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
      
      

      uprtensionwater,uprfreewater,lwrtensionwater,lwrprimaryfreewater,lwrsupplfreewater,additionalimperviousstore= sacramento(rainfall,pet,uprtensionwater,uprfreewater,lwrtensionwater,lwrprimaryfreewater,lwrsupplfreewater,additionalimperviousstore,lzpk,lzsk,uzk,uztwm,uzfwm,lztwm,lzfsm,lzfpm,pfree,rexp,zperc,side,ssout,pctim,adimp,sarva,rserv,uh1,uh2,uh3,uh4,uh5,actualet,runoff,imperviousrunoff,surfacerunoff,baseflow)

      
      
      initialStates.Set1(0, uprtensionwater)
      
      initialStates.Set1(1, uprfreewater)
      
      initialStates.Set1(2, lwrtensionwater)
      
      initialStates.Set1(3, lwrprimaryfreewater)
      
      initialStates.Set1(4, lwrsupplfreewater)
      
      initialStates.Set1(5, additionalimperviousstore)
      
      

  //		result.Outputs.ApplySpice([]int{i,0,0},[]int = make([]sim.Series, 5)
      

      doneChan <- i
    }(j)
	}

  for j := 0; j < numCells; j++ {
    <- doneChan
  }
//	return result
}
