package rr

/* WARNING: GENERATED CODE
 *
 * This file is generated by ow-specgen using metadata from ./models/rr/gr4j.go
 * 
 * Don't edit this file. Edit ./models/rr/gr4j.go instead!
 */
import (
//  "fmt"
  "github.com/flowmatters/openwater-core/sim"
  "github.com/flowmatters/openwater-core/data"
)


type GR4J struct {
  X1 data.ND1Float64
  X2 data.ND1Float64
  X3 data.ND1Float64
  X4 data.ND1Float64
  

  
}

func (m *GR4J) ApplyParameters(parameters data.ND2Float64) {

  nSets := parameters.Len(sim.DIMP_CELL)
  var newShape []int
  paramIdx := 0
  paramSize := 1


  paramSize = 1
  newShape = []int{ nSets}

  m.X1 = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.X2 = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.X3 = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  paramSize = 1
  newShape = []int{ nSets}

  m.X4 = parameters.Slice([]int{ paramIdx, 0}, []int{ paramSize, nSets}, nil).MustReshape(newShape).(data.ND1Float64)
  paramIdx += paramSize

  
}


func buildGR4J() sim.TimeSteppingModel {
	result := GR4J{}
	return &result
}

func init() {
	sim.Catalog["GR4J"] = buildGR4J
}

func (m *GR4J)  Description() sim.ModelDescription{
	var result sim.ModelDescription
  
  X1Dims := []string{
      }
  
  X2Dims := []string{
      }
  
  X3Dims := []string{
      }
  
  X4Dims := []string{
      }
  
	result.Parameters = []sim.ParameterDescription{
  
  sim.DescribeParameter("X1",0,"mm Capacity of the production soil (SMA) store",[]float64{ 1, 1500 },"",X1Dims),
  sim.DescribeParameter("X2",0,"mm Water exchange coefficient",[]float64{ -10, 5 },"",X2Dims),
  sim.DescribeParameter("X3",0,"mm Capacity of the routing store",[]float64{ 1, 500 },"",X3Dims),
  sim.DescribeParameter("X4",0,"days Time parameter for unit hydrographs",[]float64{ 0.5, 4 },"",X4Dims),}

  result.Inputs = []string{
  "rainfall","pet",}
  result.Outputs = []string{
  "runoff",}

  result.States = []string{
  "s","r","n1","n2","q1","q9",}

  result.Dimensions = []string{
      }
	return result
}

func (m *GR4J) InitialiseDimensions(dims []int) {
  
}

func (m *GR4J) FindDimensions(parameters data.ND2Float64) []int {
  
  return []int{}
  
}


func (m *GR4J) InitialiseStates(n int) data.ND2Float64 {
	var result data.ND2Float64 = nil

  
  x1Len := m.X1.Shape()[0]
  
  x2Len := m.X2.Shape()[0]
  
  x3Len := m.X3.Shape()[0]
  
  x4Len := m.X4.Shape()[0]
  

	for i := 0; i < n; i++ {
    
		x1 := m.X1.Get1(i%x1Len)
    
		x2 := m.X2.Get1(i%x2Len)
    
		x3 := m.X3.Get1(i%x3Len)
    
		x4 := m.X4.Get1(i%x4Len)
    

		states := initGR4J(x1,x2,x3,x4,)

    if result==nil {
      result = data.NewArray2DFloat64(n,states.Len(1))
    }
    result.ApplySlice([]int{i,0},[]int{1,1},states)
	}
 
	return result
}





func (m *GR4J) Run(inputs data.ND3Float64, states data.ND2Float64, outputs data.ND3Float64) {

  // Loop over all cells
  inputDims := inputs.Shape()
  numCells := states.Len(sim.DIMS_CELL)
  numStates := states.Len(sim.DIMS_STATE)
  numInputSequences := inputs.Len(sim.DIMI_CELL)

  //  fmt.Println("num cells",lenStates,"num states",numStates)
  // fmt.Println("states shape",states.Shape())
  // fmt.Println("states",states) 
  inputLen := inputDims[sim.DIMI_TIMESTEP]
  cellInputsShape := inputDims[1:]
  inputNewShape := []int{inputLen}

//  outputPosSlice := outputs.NewIndex(0)
  outputStepSlice := outputs.NewIndex(1)
  outputSizeSlice := outputs.NewIndex(1)
  outputSizeSlice[sim.DIMO_TIMESTEP] = inputLen

//  statesPosSlice := states.NewIndex(0)
  statesSizeSlice := states.NewIndex(1)
  statesSizeSlice[sim.DIMS_STATE] = numStates

//  inputsPosSlice := inputs.NewIndex(0)
  inputsSizeSlice := inputs.NewIndex(1)
  inputsSizeSlice[sim.DIMI_INPUT] = inputDims[sim.DIMI_INPUT]
  inputsSizeSlice[sim.DIMI_TIMESTEP] = inputLen

//  var result sim.RunResults
//	result.Outputs = data.NewArray3DFloat64( 1, inputLen, numCells)
//	result.States = states  //clone? make([]sim.StateSet, len(states))

  doneChan := make(chan int)
  // fmt.Println("Running GR4J for ",numCells,"cells")
//  for i := 0; i < numCells; i++ {
  for j := 0; j < numCells; j++ {
    go func(i int){
      outputPosSlice := outputs.NewIndex(0)
      statesPosSlice := states.NewIndex(0)
      inputsPosSlice := inputs.NewIndex(0)

      outputPosSlice[sim.DIMO_CELL] = i
      statesPosSlice[sim.DIMS_CELL] = i
      inputsPosSlice[sim.DIMI_CELL] = i%numInputSequences

      x1 := m.X1.Get1(i%m.X1.Len1())
      x2 := m.X2.Get1(i%m.X2.Len1())
      x3 := m.X3.Get1(i%m.X3.Len1())
      x4 := m.X4.Get1(i%m.X4.Len1())
      

      // fmt.Println("i",i)
      // fmt.Println("States",states.Shape())
      // fmt.Println("Tmp2",tmp2.Shape())
      
      initialStates := states.Slice(statesPosSlice,statesSizeSlice,nil).MustReshape([]int{numStates}).(data.ND1Float64)
      

      
      s,r,n1,n2,q1,q9 := extractGR4JStates(initialStates)
      

  //    fmt.Println("is",inputDims,"tmpShape",tmpCI.Shape(),"cis",cellInputsShape)

      cellInputs := inputs.Slice(inputsPosSlice,inputsSizeSlice,nil).MustReshape(cellInputsShape)
  //    fmt.Println("cellInputs Shape",cellInputs.Shape())
      
  //    fmt.Println("{rainfall mm}",tmpTS.Shape())
      rainfall := cellInputs.Slice([]int{ 0,0}, []int{ 1,inputLen}, nil).MustReshape(inputNewShape).(data.ND1Float64)
      
  //    fmt.Println("{pet mm}",tmpTS.Shape())
      pet := cellInputs.Slice([]int{ 1,0}, []int{ 1,inputLen}, nil).MustReshape(inputNewShape).(data.ND1Float64)
      

      

      
      
      outputPosSlice[sim.DIMO_OUTPUT] = 0
      runoff := outputs.Slice(outputPosSlice,outputSizeSlice,outputStepSlice).MustReshape([]int{inputLen}).(data.ND1Float64)
      
      

      s,r,n1,n2,q1,q9= gr4j(rainfall,pet,s,r,n1,n2,q1,q9,x1,x2,x3,x4,runoff)

      
      // TODO Retrieve states
      states.ApplySlice([]int{i,0},[]int{0,1},packGR4JStates(s,r,n1,n2,q1,q9))
      

  //		result.Outputs.ApplySpice([]int{i,0,0},[]int = make([]sim.Series, 1)
      

      doneChan <- i
    }(j)
	}

  for j := 0; j < numCells; j++ {
    <- doneChan
  }
//	return result
}
