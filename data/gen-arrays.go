// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package data

import (
	"github.com/flowmatters/openwater-core/util/slice"
)

// type NDArray interface {
// }

type NDFloat64 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) float64
	Set(loc []int, val float64)
	Slice(loc []int, dims []int, step []int) NDFloat64
	Apply(loc []int, dim int, step int, vals []float64)
	ApplySlice(loc []int, step []int, vals NDFloat64)
	CopyFrom(other NDFloat64)
	Contiguous() bool
	Unroll() []float64
	Reshape(newShape []int) (NDFloat64, error)
	MustReshape(newShape []int) NDFloat64
	ReshapeFast(newShape []int) (NDFloat64, error)
}

type ND1Float64 interface {
	NDFloat64
	Len1() int
	Get1(loc int) float64
	Set1(loc int, val float64)
	Apply1(loc int, step int, vals []float64)
}

type ND2Float64 interface {
	NDFloat64
	Len2() int
	Get2(loc1 int, loc2 int) float64
	Set2(loc1 int, loc2 int, val float64)
}

type ND3Float64 interface {
	NDFloat64
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) float64
	Set3(loc1 int, loc2 int, loc3 int, val float64)
}

type ndfloat64Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *ndfloat64Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *ndfloat64Common) Shape() []int {
	return nd.Dims
}

func (nd *ndfloat64Common) NDims() int {
	return len(nd.Dims)
}

func (nd *ndfloat64Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *ndfloat64Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *ndfloat64Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *ndfloat64Common) Len1() int {
	return nd.Dims[0]
}

func (nd *ndfloat64Common) Len2() int {
	return nd.Dims[1]
}

func (nd *ndfloat64Common) Len3() int {
	return nd.Dims[2]
}

func (nd *ndfloat64Common) slice(dest *ndfloat64Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = multiply(nd.Step, step)
	}
	dest.OffsetStep = multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDFloat32 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) float32
	Set(loc []int, val float32)
	Slice(loc []int, dims []int, step []int) NDFloat32
	Apply(loc []int, dim int, step int, vals []float32)
	ApplySlice(loc []int, step []int, vals NDFloat32)
	CopyFrom(other NDFloat32)
	Contiguous() bool
	Unroll() []float32
	Reshape(newShape []int) (NDFloat32, error)
	MustReshape(newShape []int) NDFloat32
	ReshapeFast(newShape []int) (NDFloat32, error)
}

type ND1Float32 interface {
	NDFloat32
	Len1() int
	Get1(loc int) float32
	Set1(loc int, val float32)
	Apply1(loc int, step int, vals []float32)
}

type ND2Float32 interface {
	NDFloat32
	Len2() int
	Get2(loc1 int, loc2 int) float32
	Set2(loc1 int, loc2 int, val float32)
}

type ND3Float32 interface {
	NDFloat32
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) float32
	Set3(loc1 int, loc2 int, loc3 int, val float32)
}

type ndfloat32Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *ndfloat32Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *ndfloat32Common) Shape() []int {
	return nd.Dims
}

func (nd *ndfloat32Common) NDims() int {
	return len(nd.Dims)
}

func (nd *ndfloat32Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *ndfloat32Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *ndfloat32Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *ndfloat32Common) Len1() int {
	return nd.Dims[0]
}

func (nd *ndfloat32Common) Len2() int {
	return nd.Dims[1]
}

func (nd *ndfloat32Common) Len3() int {
	return nd.Dims[2]
}

func (nd *ndfloat32Common) slice(dest *ndfloat32Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = multiply(nd.Step, step)
	}
	dest.OffsetStep = multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDInt32 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) int32
	Set(loc []int, val int32)
	Slice(loc []int, dims []int, step []int) NDInt32
	Apply(loc []int, dim int, step int, vals []int32)
	ApplySlice(loc []int, step []int, vals NDInt32)
	CopyFrom(other NDInt32)
	Contiguous() bool
	Unroll() []int32
	Reshape(newShape []int) (NDInt32, error)
	MustReshape(newShape []int) NDInt32
	ReshapeFast(newShape []int) (NDInt32, error)
}

type ND1Int32 interface {
	NDInt32
	Len1() int
	Get1(loc int) int32
	Set1(loc int, val int32)
	Apply1(loc int, step int, vals []int32)
}

type ND2Int32 interface {
	NDInt32
	Len2() int
	Get2(loc1 int, loc2 int) int32
	Set2(loc1 int, loc2 int, val int32)
}

type ND3Int32 interface {
	NDInt32
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) int32
	Set3(loc1 int, loc2 int, loc3 int, val int32)
}

type ndint32Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *ndint32Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *ndint32Common) Shape() []int {
	return nd.Dims
}

func (nd *ndint32Common) NDims() int {
	return len(nd.Dims)
}

func (nd *ndint32Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *ndint32Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *ndint32Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *ndint32Common) Len1() int {
	return nd.Dims[0]
}

func (nd *ndint32Common) Len2() int {
	return nd.Dims[1]
}

func (nd *ndint32Common) Len3() int {
	return nd.Dims[2]
}

func (nd *ndint32Common) slice(dest *ndint32Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = multiply(nd.Step, step)
	}
	dest.OffsetStep = multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDUint32 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) uint32
	Set(loc []int, val uint32)
	Slice(loc []int, dims []int, step []int) NDUint32
	Apply(loc []int, dim int, step int, vals []uint32)
	ApplySlice(loc []int, step []int, vals NDUint32)
	CopyFrom(other NDUint32)
	Contiguous() bool
	Unroll() []uint32
	Reshape(newShape []int) (NDUint32, error)
	MustReshape(newShape []int) NDUint32
	ReshapeFast(newShape []int) (NDUint32, error)
}

type ND1Uint32 interface {
	NDUint32
	Len1() int
	Get1(loc int) uint32
	Set1(loc int, val uint32)
	Apply1(loc int, step int, vals []uint32)
}

type ND2Uint32 interface {
	NDUint32
	Len2() int
	Get2(loc1 int, loc2 int) uint32
	Set2(loc1 int, loc2 int, val uint32)
}

type ND3Uint32 interface {
	NDUint32
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) uint32
	Set3(loc1 int, loc2 int, loc3 int, val uint32)
}

type nduint32Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *nduint32Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *nduint32Common) Shape() []int {
	return nd.Dims
}

func (nd *nduint32Common) NDims() int {
	return len(nd.Dims)
}

func (nd *nduint32Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *nduint32Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *nduint32Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *nduint32Common) Len1() int {
	return nd.Dims[0]
}

func (nd *nduint32Common) Len2() int {
	return nd.Dims[1]
}

func (nd *nduint32Common) Len3() int {
	return nd.Dims[2]
}

func (nd *nduint32Common) slice(dest *nduint32Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = multiply(nd.Step, step)
	}
	dest.OffsetStep = multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDInt64 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) int64
	Set(loc []int, val int64)
	Slice(loc []int, dims []int, step []int) NDInt64
	Apply(loc []int, dim int, step int, vals []int64)
	ApplySlice(loc []int, step []int, vals NDInt64)
	CopyFrom(other NDInt64)
	Contiguous() bool
	Unroll() []int64
	Reshape(newShape []int) (NDInt64, error)
	MustReshape(newShape []int) NDInt64
	ReshapeFast(newShape []int) (NDInt64, error)
}

type ND1Int64 interface {
	NDInt64
	Len1() int
	Get1(loc int) int64
	Set1(loc int, val int64)
	Apply1(loc int, step int, vals []int64)
}

type ND2Int64 interface {
	NDInt64
	Len2() int
	Get2(loc1 int, loc2 int) int64
	Set2(loc1 int, loc2 int, val int64)
}

type ND3Int64 interface {
	NDInt64
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) int64
	Set3(loc1 int, loc2 int, loc3 int, val int64)
}

type ndint64Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *ndint64Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *ndint64Common) Shape() []int {
	return nd.Dims
}

func (nd *ndint64Common) NDims() int {
	return len(nd.Dims)
}

func (nd *ndint64Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *ndint64Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *ndint64Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *ndint64Common) Len1() int {
	return nd.Dims[0]
}

func (nd *ndint64Common) Len2() int {
	return nd.Dims[1]
}

func (nd *ndint64Common) Len3() int {
	return nd.Dims[2]
}

func (nd *ndint64Common) slice(dest *ndint64Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = multiply(nd.Step, step)
	}
	dest.OffsetStep = multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDUint64 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) uint64
	Set(loc []int, val uint64)
	Slice(loc []int, dims []int, step []int) NDUint64
	Apply(loc []int, dim int, step int, vals []uint64)
	ApplySlice(loc []int, step []int, vals NDUint64)
	CopyFrom(other NDUint64)
	Contiguous() bool
	Unroll() []uint64
	Reshape(newShape []int) (NDUint64, error)
	MustReshape(newShape []int) NDUint64
	ReshapeFast(newShape []int) (NDUint64, error)
}

type ND1Uint64 interface {
	NDUint64
	Len1() int
	Get1(loc int) uint64
	Set1(loc int, val uint64)
	Apply1(loc int, step int, vals []uint64)
}

type ND2Uint64 interface {
	NDUint64
	Len2() int
	Get2(loc1 int, loc2 int) uint64
	Set2(loc1 int, loc2 int, val uint64)
}

type ND3Uint64 interface {
	NDUint64
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) uint64
	Set3(loc1 int, loc2 int, loc3 int, val uint64)
}

type nduint64Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *nduint64Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *nduint64Common) Shape() []int {
	return nd.Dims
}

func (nd *nduint64Common) NDims() int {
	return len(nd.Dims)
}

func (nd *nduint64Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *nduint64Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *nduint64Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *nduint64Common) Len1() int {
	return nd.Dims[0]
}

func (nd *nduint64Common) Len2() int {
	return nd.Dims[1]
}

func (nd *nduint64Common) Len3() int {
	return nd.Dims[2]
}

func (nd *nduint64Common) slice(dest *nduint64Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = multiply(nd.Step, step)
	}
	dest.OffsetStep = multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDInt interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) int
	Set(loc []int, val int)
	Slice(loc []int, dims []int, step []int) NDInt
	Apply(loc []int, dim int, step int, vals []int)
	ApplySlice(loc []int, step []int, vals NDInt)
	CopyFrom(other NDInt)
	Contiguous() bool
	Unroll() []int
	Reshape(newShape []int) (NDInt, error)
	MustReshape(newShape []int) NDInt
	ReshapeFast(newShape []int) (NDInt, error)
}

type ND1Int interface {
	NDInt
	Len1() int
	Get1(loc int) int
	Set1(loc int, val int)
	Apply1(loc int, step int, vals []int)
}

type ND2Int interface {
	NDInt
	Len2() int
	Get2(loc1 int, loc2 int) int
	Set2(loc1 int, loc2 int, val int)
}

type ND3Int interface {
	NDInt
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) int
	Set3(loc1 int, loc2 int, loc3 int, val int)
}

type ndintCommon struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *ndintCommon) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *ndintCommon) Shape() []int {
	return nd.Dims
}

func (nd *ndintCommon) NDims() int {
	return len(nd.Dims)
}

func (nd *ndintCommon) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *ndintCommon) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *ndintCommon) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *ndintCommon) Len1() int {
	return nd.Dims[0]
}

func (nd *ndintCommon) Len2() int {
	return nd.Dims[1]
}

func (nd *ndintCommon) Len3() int {
	return nd.Dims[2]
}

func (nd *ndintCommon) slice(dest *ndintCommon, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = multiply(nd.Step, step)
	}
	dest.OffsetStep = multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDUint interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) uint
	Set(loc []int, val uint)
	Slice(loc []int, dims []int, step []int) NDUint
	Apply(loc []int, dim int, step int, vals []uint)
	ApplySlice(loc []int, step []int, vals NDUint)
	CopyFrom(other NDUint)
	Contiguous() bool
	Unroll() []uint
	Reshape(newShape []int) (NDUint, error)
	MustReshape(newShape []int) NDUint
	ReshapeFast(newShape []int) (NDUint, error)
}

type ND1Uint interface {
	NDUint
	Len1() int
	Get1(loc int) uint
	Set1(loc int, val uint)
	Apply1(loc int, step int, vals []uint)
}

type ND2Uint interface {
	NDUint
	Len2() int
	Get2(loc1 int, loc2 int) uint
	Set2(loc1 int, loc2 int, val uint)
}

type ND3Uint interface {
	NDUint
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) uint
	Set3(loc1 int, loc2 int, loc3 int, val uint)
}

type nduintCommon struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *nduintCommon) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *nduintCommon) Shape() []int {
	return nd.Dims
}

func (nd *nduintCommon) NDims() int {
	return len(nd.Dims)
}

func (nd *nduintCommon) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *nduintCommon) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *nduintCommon) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *nduintCommon) Len1() int {
	return nd.Dims[0]
}

func (nd *nduintCommon) Len2() int {
	return nd.Dims[1]
}

func (nd *nduintCommon) Len3() int {
	return nd.Dims[2]
}

func (nd *nduintCommon) slice(dest *nduintCommon, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = multiply(nd.Step, step)
	}
	dest.OffsetStep = multiply(dest.Step, dest.Offset)
}
