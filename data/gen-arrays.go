// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/joelrahman/genny

package data

import (
	"github.com/flowmatters/openwater-core/util/slice"
)

// type NDArray interface {
// }

type NDFloat64 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) float64
	Set(loc []int, val float64)
	Slice(loc []int, dims []int, step []int) NDFloat64
	Apply(loc []int, dim int, step int, vals []float64)
	ApplySlice(loc []int, step []int, vals NDFloat64)
	CopyFrom(other NDFloat64)
	Contiguous() bool
	Unroll() []float64
	Reshape(newShape []int) (NDFloat64, error)
	MustReshape(newShape []int) NDFloat64
	ReshapeFast(newShape []int) (NDFloat64, error)
	Maximum() float64
}

type ND1Float64 interface {
	NDFloat64
	Len1() int
	Get1(loc int) float64
	Set1(loc int, val float64)
	Apply1(loc int, step int, vals []float64)
}

type ND2Float64 interface {
	NDFloat64
	Len2() int
	Get2(loc1 int, loc2 int) float64
	Set2(loc1 int, loc2 int, val float64)
}

type ND3Float64 interface {
	NDFloat64
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) float64
	Set3(loc1 int, loc2 int, loc3 int, val float64)
}

type NdFloat64Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *NdFloat64Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *NdFloat64Common) Shape() []int {
	return nd.Dims
}

func (nd *NdFloat64Common) NDims() int {
	return len(nd.Dims)
}

func (nd *NdFloat64Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *NdFloat64Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *NdFloat64Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *NdFloat64Common) Len1() int {
	return nd.Dims[0]
}

func (nd *NdFloat64Common) Len2() int {
	return nd.Dims[1]
}

func (nd *NdFloat64Common) Len3() int {
	return nd.Dims[2]
}

func (nd *NdFloat64Common) SliceInto(dest *NdFloat64Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = Multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = Multiply(nd.Step, step)
	}
	dest.OffsetStep = Multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDFloat32 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) float32
	Set(loc []int, val float32)
	Slice(loc []int, dims []int, step []int) NDFloat32
	Apply(loc []int, dim int, step int, vals []float32)
	ApplySlice(loc []int, step []int, vals NDFloat32)
	CopyFrom(other NDFloat32)
	Contiguous() bool
	Unroll() []float32
	Reshape(newShape []int) (NDFloat32, error)
	MustReshape(newShape []int) NDFloat32
	ReshapeFast(newShape []int) (NDFloat32, error)
	Maximum() float32
}

type ND1Float32 interface {
	NDFloat32
	Len1() int
	Get1(loc int) float32
	Set1(loc int, val float32)
	Apply1(loc int, step int, vals []float32)
}

type ND2Float32 interface {
	NDFloat32
	Len2() int
	Get2(loc1 int, loc2 int) float32
	Set2(loc1 int, loc2 int, val float32)
}

type ND3Float32 interface {
	NDFloat32
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) float32
	Set3(loc1 int, loc2 int, loc3 int, val float32)
}

type NdFloat32Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *NdFloat32Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *NdFloat32Common) Shape() []int {
	return nd.Dims
}

func (nd *NdFloat32Common) NDims() int {
	return len(nd.Dims)
}

func (nd *NdFloat32Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *NdFloat32Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *NdFloat32Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *NdFloat32Common) Len1() int {
	return nd.Dims[0]
}

func (nd *NdFloat32Common) Len2() int {
	return nd.Dims[1]
}

func (nd *NdFloat32Common) Len3() int {
	return nd.Dims[2]
}

func (nd *NdFloat32Common) SliceInto(dest *NdFloat32Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = Multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = Multiply(nd.Step, step)
	}
	dest.OffsetStep = Multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDInt32 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) int32
	Set(loc []int, val int32)
	Slice(loc []int, dims []int, step []int) NDInt32
	Apply(loc []int, dim int, step int, vals []int32)
	ApplySlice(loc []int, step []int, vals NDInt32)
	CopyFrom(other NDInt32)
	Contiguous() bool
	Unroll() []int32
	Reshape(newShape []int) (NDInt32, error)
	MustReshape(newShape []int) NDInt32
	ReshapeFast(newShape []int) (NDInt32, error)
	Maximum() int32
}

type ND1Int32 interface {
	NDInt32
	Len1() int
	Get1(loc int) int32
	Set1(loc int, val int32)
	Apply1(loc int, step int, vals []int32)
}

type ND2Int32 interface {
	NDInt32
	Len2() int
	Get2(loc1 int, loc2 int) int32
	Set2(loc1 int, loc2 int, val int32)
}

type ND3Int32 interface {
	NDInt32
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) int32
	Set3(loc1 int, loc2 int, loc3 int, val int32)
}

type NdInt32Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *NdInt32Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *NdInt32Common) Shape() []int {
	return nd.Dims
}

func (nd *NdInt32Common) NDims() int {
	return len(nd.Dims)
}

func (nd *NdInt32Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *NdInt32Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *NdInt32Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *NdInt32Common) Len1() int {
	return nd.Dims[0]
}

func (nd *NdInt32Common) Len2() int {
	return nd.Dims[1]
}

func (nd *NdInt32Common) Len3() int {
	return nd.Dims[2]
}

func (nd *NdInt32Common) SliceInto(dest *NdInt32Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = Multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = Multiply(nd.Step, step)
	}
	dest.OffsetStep = Multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDUint32 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) uint32
	Set(loc []int, val uint32)
	Slice(loc []int, dims []int, step []int) NDUint32
	Apply(loc []int, dim int, step int, vals []uint32)
	ApplySlice(loc []int, step []int, vals NDUint32)
	CopyFrom(other NDUint32)
	Contiguous() bool
	Unroll() []uint32
	Reshape(newShape []int) (NDUint32, error)
	MustReshape(newShape []int) NDUint32
	ReshapeFast(newShape []int) (NDUint32, error)
	Maximum() uint32
}

type ND1Uint32 interface {
	NDUint32
	Len1() int
	Get1(loc int) uint32
	Set1(loc int, val uint32)
	Apply1(loc int, step int, vals []uint32)
}

type ND2Uint32 interface {
	NDUint32
	Len2() int
	Get2(loc1 int, loc2 int) uint32
	Set2(loc1 int, loc2 int, val uint32)
}

type ND3Uint32 interface {
	NDUint32
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) uint32
	Set3(loc1 int, loc2 int, loc3 int, val uint32)
}

type NdUint32Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *NdUint32Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *NdUint32Common) Shape() []int {
	return nd.Dims
}

func (nd *NdUint32Common) NDims() int {
	return len(nd.Dims)
}

func (nd *NdUint32Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *NdUint32Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *NdUint32Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *NdUint32Common) Len1() int {
	return nd.Dims[0]
}

func (nd *NdUint32Common) Len2() int {
	return nd.Dims[1]
}

func (nd *NdUint32Common) Len3() int {
	return nd.Dims[2]
}

func (nd *NdUint32Common) SliceInto(dest *NdUint32Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = Multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = Multiply(nd.Step, step)
	}
	dest.OffsetStep = Multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDInt64 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) int64
	Set(loc []int, val int64)
	Slice(loc []int, dims []int, step []int) NDInt64
	Apply(loc []int, dim int, step int, vals []int64)
	ApplySlice(loc []int, step []int, vals NDInt64)
	CopyFrom(other NDInt64)
	Contiguous() bool
	Unroll() []int64
	Reshape(newShape []int) (NDInt64, error)
	MustReshape(newShape []int) NDInt64
	ReshapeFast(newShape []int) (NDInt64, error)
	Maximum() int64
}

type ND1Int64 interface {
	NDInt64
	Len1() int
	Get1(loc int) int64
	Set1(loc int, val int64)
	Apply1(loc int, step int, vals []int64)
}

type ND2Int64 interface {
	NDInt64
	Len2() int
	Get2(loc1 int, loc2 int) int64
	Set2(loc1 int, loc2 int, val int64)
}

type ND3Int64 interface {
	NDInt64
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) int64
	Set3(loc1 int, loc2 int, loc3 int, val int64)
}

type NdInt64Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *NdInt64Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *NdInt64Common) Shape() []int {
	return nd.Dims
}

func (nd *NdInt64Common) NDims() int {
	return len(nd.Dims)
}

func (nd *NdInt64Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *NdInt64Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *NdInt64Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *NdInt64Common) Len1() int {
	return nd.Dims[0]
}

func (nd *NdInt64Common) Len2() int {
	return nd.Dims[1]
}

func (nd *NdInt64Common) Len3() int {
	return nd.Dims[2]
}

func (nd *NdInt64Common) SliceInto(dest *NdInt64Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = Multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = Multiply(nd.Step, step)
	}
	dest.OffsetStep = Multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDUint64 interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) uint64
	Set(loc []int, val uint64)
	Slice(loc []int, dims []int, step []int) NDUint64
	Apply(loc []int, dim int, step int, vals []uint64)
	ApplySlice(loc []int, step []int, vals NDUint64)
	CopyFrom(other NDUint64)
	Contiguous() bool
	Unroll() []uint64
	Reshape(newShape []int) (NDUint64, error)
	MustReshape(newShape []int) NDUint64
	ReshapeFast(newShape []int) (NDUint64, error)
	Maximum() uint64
}

type ND1Uint64 interface {
	NDUint64
	Len1() int
	Get1(loc int) uint64
	Set1(loc int, val uint64)
	Apply1(loc int, step int, vals []uint64)
}

type ND2Uint64 interface {
	NDUint64
	Len2() int
	Get2(loc1 int, loc2 int) uint64
	Set2(loc1 int, loc2 int, val uint64)
}

type ND3Uint64 interface {
	NDUint64
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) uint64
	Set3(loc1 int, loc2 int, loc3 int, val uint64)
}

type NdUint64Common struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *NdUint64Common) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *NdUint64Common) Shape() []int {
	return nd.Dims
}

func (nd *NdUint64Common) NDims() int {
	return len(nd.Dims)
}

func (nd *NdUint64Common) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *NdUint64Common) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *NdUint64Common) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *NdUint64Common) Len1() int {
	return nd.Dims[0]
}

func (nd *NdUint64Common) Len2() int {
	return nd.Dims[1]
}

func (nd *NdUint64Common) Len3() int {
	return nd.Dims[2]
}

func (nd *NdUint64Common) SliceInto(dest *NdUint64Common, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = Multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = Multiply(nd.Step, step)
	}
	dest.OffsetStep = Multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDInt interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) int
	Set(loc []int, val int)
	Slice(loc []int, dims []int, step []int) NDInt
	Apply(loc []int, dim int, step int, vals []int)
	ApplySlice(loc []int, step []int, vals NDInt)
	CopyFrom(other NDInt)
	Contiguous() bool
	Unroll() []int
	Reshape(newShape []int) (NDInt, error)
	MustReshape(newShape []int) NDInt
	ReshapeFast(newShape []int) (NDInt, error)
	Maximum() int
}

type ND1Int interface {
	NDInt
	Len1() int
	Get1(loc int) int
	Set1(loc int, val int)
	Apply1(loc int, step int, vals []int)
}

type ND2Int interface {
	NDInt
	Len2() int
	Get2(loc1 int, loc2 int) int
	Set2(loc1 int, loc2 int, val int)
}

type ND3Int interface {
	NDInt
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) int
	Set3(loc1 int, loc2 int, loc3 int, val int)
}

type NdIntCommon struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *NdIntCommon) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *NdIntCommon) Shape() []int {
	return nd.Dims
}

func (nd *NdIntCommon) NDims() int {
	return len(nd.Dims)
}

func (nd *NdIntCommon) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *NdIntCommon) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *NdIntCommon) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *NdIntCommon) Len1() int {
	return nd.Dims[0]
}

func (nd *NdIntCommon) Len2() int {
	return nd.Dims[1]
}

func (nd *NdIntCommon) Len3() int {
	return nd.Dims[2]
}

func (nd *NdIntCommon) SliceInto(dest *NdIntCommon, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = Multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = Multiply(nd.Step, step)
	}
	dest.OffsetStep = Multiply(dest.Step, dest.Offset)
}

// type NDArray interface {
// }

type NDUint interface {
	Len(axis int) int
	Shape() []int
	NDims() int
	NewIndex(val int) []int

	Get(loc []int) uint
	Set(loc []int, val uint)
	Slice(loc []int, dims []int, step []int) NDUint
	Apply(loc []int, dim int, step int, vals []uint)
	ApplySlice(loc []int, step []int, vals NDUint)
	CopyFrom(other NDUint)
	Contiguous() bool
	Unroll() []uint
	Reshape(newShape []int) (NDUint, error)
	MustReshape(newShape []int) NDUint
	ReshapeFast(newShape []int) (NDUint, error)
	Maximum() uint
}

type ND1Uint interface {
	NDUint
	Len1() int
	Get1(loc int) uint
	Set1(loc int, val uint)
	Apply1(loc int, step int, vals []uint)
}

type ND2Uint interface {
	NDUint
	Len2() int
	Get2(loc1 int, loc2 int) uint
	Set2(loc1 int, loc2 int, val uint)
}

type ND3Uint interface {
	NDUint
	Len3() int
	Get3(loc1 int, loc2 int, loc3 int) uint
	Set3(loc1 int, loc2 int, loc3 int, val uint)
}

type NdUintCommon struct {
	OriginalDims []int
	Dims         []int
	Start        int
	Offset       []int
	Step         []int
	OffsetStep   []int
}

func (nd *NdUintCommon) Len(ax int) int {
	return nd.Dims[ax]
}

func (nd *NdUintCommon) Shape() []int {
	return nd.Dims
}

func (nd *NdUintCommon) NDims() int {
	return len(nd.Dims)
}

func (nd *NdUintCommon) NewIndex(val int) []int {
	return slice.Uniform(nd.NDims(), val)
}

func (nd *NdUintCommon) Index(loc []int) int {
	result := nd.Start
	for i := 0; i < len(loc); i++ {
		result += loc[i] * nd.OffsetStep[i]
	}
	return result

	//	return nd.Start + dotProduct(multiply(loc, nd.Step), nd.Offset)
}

func (nd *NdUintCommon) Contiguous() bool {
	// What about step!
	var i int
	contiguousOffset := 1
	dimsMustBeOne := false

	for i = len(nd.Dims) - 1; i >= 0; i-- {
		if nd.Dims[i] > 1 {
			if dimsMustBeOne {
				return false
			}

			if nd.Step[i] > 1 {
				return false
			}

			if nd.Offset[i] > contiguousOffset {
				return false
			}
		}

		if nd.Dims[i] != nd.OriginalDims[i] {
			dimsMustBeOne = true
		}

		contiguousOffset *= nd.Dims[i]
	}

	return true
}

func (nd *NdUintCommon) Len1() int {
	return nd.Dims[0]
}

func (nd *NdUintCommon) Len2() int {
	return nd.Dims[1]
}

func (nd *NdUintCommon) Len3() int {
	return nd.Dims[2]
}

func (nd *NdUintCommon) SliceInto(dest *NdUintCommon, loc []int, dims []int, step []int) {
	dest.OriginalDims = nd.OriginalDims
	dest.Dims = dims
	dest.Start = nd.Start + dotProduct(loc, nd.Offset)
	dest.Offset = Multiply(nd.Offset, nd.Step)

	if step == nil {
		dest.Step = nd.Step
	} else {
		dest.Step = Multiply(nd.Step, step)
	}
	dest.OffsetStep = Multiply(dest.Step, dest.Offset)
}
