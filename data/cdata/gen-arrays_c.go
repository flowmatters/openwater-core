// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/joelrahman/genny

package cdata

import "C"

import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/flowmatters/openwater-core/data"
	"github.com/flowmatters/openwater-core/util/slice"
)

type ndfloat64C struct {
	data.NdFloat64Common
	//	Impl *C.double
	Impl *[1 << 30]C.double
	//p2 := (*[1<<30]C.int)(unsafe.Pointer(p))
}

// func ArrayFromC(impl *C.double, shape []int) NDFloat64 {
// res := ndfloat64C{}
// 	res.Dims = shape
// 	res.OriginalDims = shape
// 	res.Start = 0
// 	res.Offset = uniform(len(shape), 0)
// 	res.Step = ones(len(shape))
// 	res.Impl = impl
// 	return &res
// }

func (nd *ndfloat64C) Get(loc []int) float64 {
	return float64(nd.Impl[nd.Index(loc)])
}

func (nd *ndfloat64C) Set(loc []int, val float64) {
	nd.Impl[nd.Index(loc)] = C.double(val)
}

func (nd *ndfloat64C) Slice(loc []int, dims []int, step []int) data.NDFloat64 {
	result := ndfloat64C{}
	nd.SliceInto(&result.NdFloat64Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *ndfloat64C) Apply(loc []int, dim int, step int, vals []float64) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	//	slice := nd.Slice(loc, sliceDim, sliceStep)

	// if slice.Contiguous() {
	// concrete := slice.(*ndfloat64C)
	// 	implSlice := concrete.Impl
	// 	subset := implSlice[concrete.Start : concrete.Start+len(vals)]
	// 	copy(subset, vals)
	// } else {
	start := loc[dim]
	for i, v := range vals {
		loc[dim] = start + i*step
		nd.Set(loc, v)
	}
	loc[dim] = start
	// }
}

func (nd *ndfloat64C) ApplySlice(loc []int, step []int, vals data.NDFloat64) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)

	idx := slice.NewIndex(0)
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		data.Increment(idx, shape)
	}
	// How to speed up
}

func (nd *ndfloat64C) CopyFrom(other data.NDFloat64) {
	nd.ApplySlice(nd.NewIndex(0), nil, other)
}

func (nd *ndfloat64C) Unroll() []float64 {
	// if nd.Contiguous() {
	// 	s := nd.Start
	// 	e := nd.Index(decrement(nd.Dims))
	// 	return nd.Impl[s : e+1]
	// }

	//	fmt.Println(nd)

	length := data.Product(nd.Shape())
	res := make([]float64, length)

	dimOffsets := data.Offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := data.IDivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *ndfloat64C) ReshapeFast(newShape []int) (data.NDFloat64, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *ndfloat64C) Reshape(newShape []int) (data.NDFloat64, error) {
	result := ndfloat64C{}
	size := data.Product(newShape)
	currentSize := data.Product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (data.Maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = nd.Start
		result.Impl = nd.Impl
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = slice.Ones(len(newShape))

		result.Offset = data.Offsets(newShape)
		result.OffsetStep = data.Multiply(result.Step, result.Offset)
		return &result, nil
	}

	seriesDim := data.Argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result, nil
}

func (nd *ndfloat64C) MustReshape(newShape []int) data.NDFloat64 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *ndfloat64C) Get1(loc int) float64 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *ndfloat64C) Set1(loc int, val float64) {
	nd.Set([]int{loc}, val)
}

func (nd *ndfloat64C) Apply1(loc int, step int, vals []float64) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *ndfloat64C) Get2(loc1 int, loc2 int) float64 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *ndfloat64C) Set2(loc1 int, loc2 int, val float64) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *ndfloat64C) Get3(loc1 int, loc2 int, loc3 int) float64 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *ndfloat64C) Set3(loc1 int, loc2 int, loc3 int, val float64) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func (nd *ndfloat64C) Maximum() float64 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v > res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func (nd *ndfloat64C) Minimum() float64 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v < res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func NewFloat64CArray(impl unsafe.Pointer, dims []int) data.NDFloat64 {
	return newfloat64CArray((*[1 << 30]C.double)(impl), dims)
}

func newfloat64CArray(impl *[1 << 30]C.double, dims []int) *ndfloat64C {
	result := ndfloat64C{}
	//	size := product(dims)
	result.Start = 0
	result.Impl = impl
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = slice.Ones(len(dims))
	result.Offset = data.Offsets(dims)
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result
}

func makefloat64CArrayForTest(shape []int) *ndfloat64C {
	goArray := data.ARangeFloat64(data.Product(shape)).MustReshape(shape)
	impl := goArray.Unroll()

	v := reflect.Indirect(reflect.ValueOf(&impl))
	slice := (*reflect.SliceHeader)(unsafe.Pointer(v.UnsafeAddr()))
	addr := (*[1 << 30]C.double)(unsafe.Pointer(slice.Data))

	return newfloat64CArray(addr, shape)
}

type ndfloat32C struct {
	data.NdFloat32Common
	//	Impl *C.double
	Impl *[1 << 30]C.float
	//p2 := (*[1<<30]C.int)(unsafe.Pointer(p))
}

// func ArrayFromC(impl *C.double, shape []int) NDFloat64 {
// res := ndfloat32C{}
// 	res.Dims = shape
// 	res.OriginalDims = shape
// 	res.Start = 0
// 	res.Offset = uniform(len(shape), 0)
// 	res.Step = ones(len(shape))
// 	res.Impl = impl
// 	return &res
// }

func (nd *ndfloat32C) Get(loc []int) float32 {
	return float32(nd.Impl[nd.Index(loc)])
}

func (nd *ndfloat32C) Set(loc []int, val float32) {
	nd.Impl[nd.Index(loc)] = C.float(val)
}

func (nd *ndfloat32C) Slice(loc []int, dims []int, step []int) data.NDFloat32 {
	result := ndfloat32C{}
	nd.SliceInto(&result.NdFloat32Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *ndfloat32C) Apply(loc []int, dim int, step int, vals []float32) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	//	slice := nd.Slice(loc, sliceDim, sliceStep)

	// if slice.Contiguous() {
	// concrete := slice.(*ndfloat32C)
	// 	implSlice := concrete.Impl
	// 	subset := implSlice[concrete.Start : concrete.Start+len(vals)]
	// 	copy(subset, vals)
	// } else {
	start := loc[dim]
	for i, v := range vals {
		loc[dim] = start + i*step
		nd.Set(loc, v)
	}
	loc[dim] = start
	// }
}

func (nd *ndfloat32C) ApplySlice(loc []int, step []int, vals data.NDFloat32) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)

	idx := slice.NewIndex(0)
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		data.Increment(idx, shape)
	}
	// How to speed up
}

func (nd *ndfloat32C) CopyFrom(other data.NDFloat32) {
	nd.ApplySlice(nd.NewIndex(0), nil, other)
}

func (nd *ndfloat32C) Unroll() []float32 {
	// if nd.Contiguous() {
	// 	s := nd.Start
	// 	e := nd.Index(decrement(nd.Dims))
	// 	return nd.Impl[s : e+1]
	// }

	//	fmt.Println(nd)

	length := data.Product(nd.Shape())
	res := make([]float32, length)

	dimOffsets := data.Offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := data.IDivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *ndfloat32C) ReshapeFast(newShape []int) (data.NDFloat32, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *ndfloat32C) Reshape(newShape []int) (data.NDFloat32, error) {
	result := ndfloat32C{}
	size := data.Product(newShape)
	currentSize := data.Product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (data.Maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = nd.Start
		result.Impl = nd.Impl
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = slice.Ones(len(newShape))

		result.Offset = data.Offsets(newShape)
		result.OffsetStep = data.Multiply(result.Step, result.Offset)
		return &result, nil
	}

	seriesDim := data.Argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result, nil
}

func (nd *ndfloat32C) MustReshape(newShape []int) data.NDFloat32 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *ndfloat32C) Get1(loc int) float32 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *ndfloat32C) Set1(loc int, val float32) {
	nd.Set([]int{loc}, val)
}

func (nd *ndfloat32C) Apply1(loc int, step int, vals []float32) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *ndfloat32C) Get2(loc1 int, loc2 int) float32 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *ndfloat32C) Set2(loc1 int, loc2 int, val float32) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *ndfloat32C) Get3(loc1 int, loc2 int, loc3 int) float32 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *ndfloat32C) Set3(loc1 int, loc2 int, loc3 int, val float32) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func (nd *ndfloat32C) Maximum() float32 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v > res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func (nd *ndfloat32C) Minimum() float32 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v < res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func NewFloat32CArray(impl unsafe.Pointer, dims []int) data.NDFloat32 {
	return newfloat32CArray((*[1 << 30]C.float)(impl), dims)
}

func newfloat32CArray(impl *[1 << 30]C.float, dims []int) *ndfloat32C {
	result := ndfloat32C{}
	//	size := product(dims)
	result.Start = 0
	result.Impl = impl
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = slice.Ones(len(dims))
	result.Offset = data.Offsets(dims)
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result
}

func makefloat32CArrayForTest(shape []int) *ndfloat32C {
	goArray := data.ARangeFloat32(data.Product(shape)).MustReshape(shape)
	impl := goArray.Unroll()

	v := reflect.Indirect(reflect.ValueOf(&impl))
	slice := (*reflect.SliceHeader)(unsafe.Pointer(v.UnsafeAddr()))
	addr := (*[1 << 30]C.float)(unsafe.Pointer(slice.Data))

	return newfloat32CArray(addr, shape)
}

type ndint32C struct {
	data.NdInt32Common
	//	Impl *C.double
	Impl *[1 << 30]C.int
	//p2 := (*[1<<30]C.int)(unsafe.Pointer(p))
}

// func ArrayFromC(impl *C.double, shape []int) NDFloat64 {
// res := ndint32C{}
// 	res.Dims = shape
// 	res.OriginalDims = shape
// 	res.Start = 0
// 	res.Offset = uniform(len(shape), 0)
// 	res.Step = ones(len(shape))
// 	res.Impl = impl
// 	return &res
// }

func (nd *ndint32C) Get(loc []int) int32 {
	return int32(nd.Impl[nd.Index(loc)])
}

func (nd *ndint32C) Set(loc []int, val int32) {
	nd.Impl[nd.Index(loc)] = C.int(val)
}

func (nd *ndint32C) Slice(loc []int, dims []int, step []int) data.NDInt32 {
	result := ndint32C{}
	nd.SliceInto(&result.NdInt32Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *ndint32C) Apply(loc []int, dim int, step int, vals []int32) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	//	slice := nd.Slice(loc, sliceDim, sliceStep)

	// if slice.Contiguous() {
	// concrete := slice.(*ndint32C)
	// 	implSlice := concrete.Impl
	// 	subset := implSlice[concrete.Start : concrete.Start+len(vals)]
	// 	copy(subset, vals)
	// } else {
	start := loc[dim]
	for i, v := range vals {
		loc[dim] = start + i*step
		nd.Set(loc, v)
	}
	loc[dim] = start
	// }
}

func (nd *ndint32C) ApplySlice(loc []int, step []int, vals data.NDInt32) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)

	idx := slice.NewIndex(0)
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		data.Increment(idx, shape)
	}
	// How to speed up
}

func (nd *ndint32C) CopyFrom(other data.NDInt32) {
	nd.ApplySlice(nd.NewIndex(0), nil, other)
}

func (nd *ndint32C) Unroll() []int32 {
	// if nd.Contiguous() {
	// 	s := nd.Start
	// 	e := nd.Index(decrement(nd.Dims))
	// 	return nd.Impl[s : e+1]
	// }

	//	fmt.Println(nd)

	length := data.Product(nd.Shape())
	res := make([]int32, length)

	dimOffsets := data.Offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := data.IDivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *ndint32C) ReshapeFast(newShape []int) (data.NDInt32, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *ndint32C) Reshape(newShape []int) (data.NDInt32, error) {
	result := ndint32C{}
	size := data.Product(newShape)
	currentSize := data.Product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (data.Maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = nd.Start
		result.Impl = nd.Impl
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = slice.Ones(len(newShape))

		result.Offset = data.Offsets(newShape)
		result.OffsetStep = data.Multiply(result.Step, result.Offset)
		return &result, nil
	}

	seriesDim := data.Argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result, nil
}

func (nd *ndint32C) MustReshape(newShape []int) data.NDInt32 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *ndint32C) Get1(loc int) int32 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *ndint32C) Set1(loc int, val int32) {
	nd.Set([]int{loc}, val)
}

func (nd *ndint32C) Apply1(loc int, step int, vals []int32) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *ndint32C) Get2(loc1 int, loc2 int) int32 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *ndint32C) Set2(loc1 int, loc2 int, val int32) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *ndint32C) Get3(loc1 int, loc2 int, loc3 int) int32 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *ndint32C) Set3(loc1 int, loc2 int, loc3 int, val int32) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func (nd *ndint32C) Maximum() int32 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v > res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func (nd *ndint32C) Minimum() int32 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v < res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func NewInt32CArray(impl unsafe.Pointer, dims []int) data.NDInt32 {
	return newint32CArray((*[1 << 30]C.int)(impl), dims)
}

func newint32CArray(impl *[1 << 30]C.int, dims []int) *ndint32C {
	result := ndint32C{}
	//	size := product(dims)
	result.Start = 0
	result.Impl = impl
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = slice.Ones(len(dims))
	result.Offset = data.Offsets(dims)
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result
}

func makeint32CArrayForTest(shape []int) *ndint32C {
	goArray := data.ARangeInt32(data.Product(shape)).MustReshape(shape)
	impl := goArray.Unroll()

	v := reflect.Indirect(reflect.ValueOf(&impl))
	slice := (*reflect.SliceHeader)(unsafe.Pointer(v.UnsafeAddr()))
	addr := (*[1 << 30]C.int)(unsafe.Pointer(slice.Data))

	return newint32CArray(addr, shape)
}

type nduint32C struct {
	data.NdUint32Common
	//	Impl *C.double
	Impl *[1 << 30]C.uint
	//p2 := (*[1<<30]C.int)(unsafe.Pointer(p))
}

// func ArrayFromC(impl *C.double, shape []int) NDFloat64 {
// res := nduint32C{}
// 	res.Dims = shape
// 	res.OriginalDims = shape
// 	res.Start = 0
// 	res.Offset = uniform(len(shape), 0)
// 	res.Step = ones(len(shape))
// 	res.Impl = impl
// 	return &res
// }

func (nd *nduint32C) Get(loc []int) uint32 {
	return uint32(nd.Impl[nd.Index(loc)])
}

func (nd *nduint32C) Set(loc []int, val uint32) {
	nd.Impl[nd.Index(loc)] = C.uint(val)
}

func (nd *nduint32C) Slice(loc []int, dims []int, step []int) data.NDUint32 {
	result := nduint32C{}
	nd.SliceInto(&result.NdUint32Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *nduint32C) Apply(loc []int, dim int, step int, vals []uint32) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	//	slice := nd.Slice(loc, sliceDim, sliceStep)

	// if slice.Contiguous() {
	// concrete := slice.(*nduint32C)
	// 	implSlice := concrete.Impl
	// 	subset := implSlice[concrete.Start : concrete.Start+len(vals)]
	// 	copy(subset, vals)
	// } else {
	start := loc[dim]
	for i, v := range vals {
		loc[dim] = start + i*step
		nd.Set(loc, v)
	}
	loc[dim] = start
	// }
}

func (nd *nduint32C) ApplySlice(loc []int, step []int, vals data.NDUint32) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)

	idx := slice.NewIndex(0)
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		data.Increment(idx, shape)
	}
	// How to speed up
}

func (nd *nduint32C) CopyFrom(other data.NDUint32) {
	nd.ApplySlice(nd.NewIndex(0), nil, other)
}

func (nd *nduint32C) Unroll() []uint32 {
	// if nd.Contiguous() {
	// 	s := nd.Start
	// 	e := nd.Index(decrement(nd.Dims))
	// 	return nd.Impl[s : e+1]
	// }

	//	fmt.Println(nd)

	length := data.Product(nd.Shape())
	res := make([]uint32, length)

	dimOffsets := data.Offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := data.IDivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *nduint32C) ReshapeFast(newShape []int) (data.NDUint32, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *nduint32C) Reshape(newShape []int) (data.NDUint32, error) {
	result := nduint32C{}
	size := data.Product(newShape)
	currentSize := data.Product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (data.Maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = nd.Start
		result.Impl = nd.Impl
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = slice.Ones(len(newShape))

		result.Offset = data.Offsets(newShape)
		result.OffsetStep = data.Multiply(result.Step, result.Offset)
		return &result, nil
	}

	seriesDim := data.Argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result, nil
}

func (nd *nduint32C) MustReshape(newShape []int) data.NDUint32 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *nduint32C) Get1(loc int) uint32 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *nduint32C) Set1(loc int, val uint32) {
	nd.Set([]int{loc}, val)
}

func (nd *nduint32C) Apply1(loc int, step int, vals []uint32) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *nduint32C) Get2(loc1 int, loc2 int) uint32 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *nduint32C) Set2(loc1 int, loc2 int, val uint32) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *nduint32C) Get3(loc1 int, loc2 int, loc3 int) uint32 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *nduint32C) Set3(loc1 int, loc2 int, loc3 int, val uint32) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func (nd *nduint32C) Maximum() uint32 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v > res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func (nd *nduint32C) Minimum() uint32 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v < res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func NewUint32CArray(impl unsafe.Pointer, dims []int) data.NDUint32 {
	return newuint32CArray((*[1 << 30]C.uint)(impl), dims)
}

func newuint32CArray(impl *[1 << 30]C.uint, dims []int) *nduint32C {
	result := nduint32C{}
	//	size := product(dims)
	result.Start = 0
	result.Impl = impl
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = slice.Ones(len(dims))
	result.Offset = data.Offsets(dims)
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result
}

func makeuint32CArrayForTest(shape []int) *nduint32C {
	goArray := data.ARangeUint32(data.Product(shape)).MustReshape(shape)
	impl := goArray.Unroll()

	v := reflect.Indirect(reflect.ValueOf(&impl))
	slice := (*reflect.SliceHeader)(unsafe.Pointer(v.UnsafeAddr()))
	addr := (*[1 << 30]C.uint)(unsafe.Pointer(slice.Data))

	return newuint32CArray(addr, shape)
}

type ndint64C struct {
	data.NdInt64Common
	//	Impl *C.double
	Impl *[1 << 30]C.long
	//p2 := (*[1<<30]C.int)(unsafe.Pointer(p))
}

// func ArrayFromC(impl *C.double, shape []int) NDFloat64 {
// res := ndint64C{}
// 	res.Dims = shape
// 	res.OriginalDims = shape
// 	res.Start = 0
// 	res.Offset = uniform(len(shape), 0)
// 	res.Step = ones(len(shape))
// 	res.Impl = impl
// 	return &res
// }

func (nd *ndint64C) Get(loc []int) int64 {
	return int64(nd.Impl[nd.Index(loc)])
}

func (nd *ndint64C) Set(loc []int, val int64) {
	nd.Impl[nd.Index(loc)] = C.long(val)
}

func (nd *ndint64C) Slice(loc []int, dims []int, step []int) data.NDInt64 {
	result := ndint64C{}
	nd.SliceInto(&result.NdInt64Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *ndint64C) Apply(loc []int, dim int, step int, vals []int64) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	//	slice := nd.Slice(loc, sliceDim, sliceStep)

	// if slice.Contiguous() {
	// concrete := slice.(*ndint64C)
	// 	implSlice := concrete.Impl
	// 	subset := implSlice[concrete.Start : concrete.Start+len(vals)]
	// 	copy(subset, vals)
	// } else {
	start := loc[dim]
	for i, v := range vals {
		loc[dim] = start + i*step
		nd.Set(loc, v)
	}
	loc[dim] = start
	// }
}

func (nd *ndint64C) ApplySlice(loc []int, step []int, vals data.NDInt64) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)

	idx := slice.NewIndex(0)
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		data.Increment(idx, shape)
	}
	// How to speed up
}

func (nd *ndint64C) CopyFrom(other data.NDInt64) {
	nd.ApplySlice(nd.NewIndex(0), nil, other)
}

func (nd *ndint64C) Unroll() []int64 {
	// if nd.Contiguous() {
	// 	s := nd.Start
	// 	e := nd.Index(decrement(nd.Dims))
	// 	return nd.Impl[s : e+1]
	// }

	//	fmt.Println(nd)

	length := data.Product(nd.Shape())
	res := make([]int64, length)

	dimOffsets := data.Offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := data.IDivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *ndint64C) ReshapeFast(newShape []int) (data.NDInt64, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *ndint64C) Reshape(newShape []int) (data.NDInt64, error) {
	result := ndint64C{}
	size := data.Product(newShape)
	currentSize := data.Product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (data.Maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = nd.Start
		result.Impl = nd.Impl
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = slice.Ones(len(newShape))

		result.Offset = data.Offsets(newShape)
		result.OffsetStep = data.Multiply(result.Step, result.Offset)
		return &result, nil
	}

	seriesDim := data.Argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result, nil
}

func (nd *ndint64C) MustReshape(newShape []int) data.NDInt64 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *ndint64C) Get1(loc int) int64 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *ndint64C) Set1(loc int, val int64) {
	nd.Set([]int{loc}, val)
}

func (nd *ndint64C) Apply1(loc int, step int, vals []int64) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *ndint64C) Get2(loc1 int, loc2 int) int64 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *ndint64C) Set2(loc1 int, loc2 int, val int64) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *ndint64C) Get3(loc1 int, loc2 int, loc3 int) int64 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *ndint64C) Set3(loc1 int, loc2 int, loc3 int, val int64) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func (nd *ndint64C) Maximum() int64 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v > res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func (nd *ndint64C) Minimum() int64 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v < res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func NewInt64CArray(impl unsafe.Pointer, dims []int) data.NDInt64 {
	return newint64CArray((*[1 << 30]C.long)(impl), dims)
}

func newint64CArray(impl *[1 << 30]C.long, dims []int) *ndint64C {
	result := ndint64C{}
	//	size := product(dims)
	result.Start = 0
	result.Impl = impl
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = slice.Ones(len(dims))
	result.Offset = data.Offsets(dims)
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result
}

func makeint64CArrayForTest(shape []int) *ndint64C {
	goArray := data.ARangeInt64(data.Product(shape)).MustReshape(shape)
	impl := goArray.Unroll()

	v := reflect.Indirect(reflect.ValueOf(&impl))
	slice := (*reflect.SliceHeader)(unsafe.Pointer(v.UnsafeAddr()))
	addr := (*[1 << 30]C.long)(unsafe.Pointer(slice.Data))

	return newint64CArray(addr, shape)
}

type nduint64C struct {
	data.NdUint64Common
	//	Impl *C.double
	Impl *[1 << 30]C.ulong
	//p2 := (*[1<<30]C.int)(unsafe.Pointer(p))
}

// func ArrayFromC(impl *C.double, shape []int) NDFloat64 {
// res := nduint64C{}
// 	res.Dims = shape
// 	res.OriginalDims = shape
// 	res.Start = 0
// 	res.Offset = uniform(len(shape), 0)
// 	res.Step = ones(len(shape))
// 	res.Impl = impl
// 	return &res
// }

func (nd *nduint64C) Get(loc []int) uint64 {
	return uint64(nd.Impl[nd.Index(loc)])
}

func (nd *nduint64C) Set(loc []int, val uint64) {
	nd.Impl[nd.Index(loc)] = C.ulong(val)
}

func (nd *nduint64C) Slice(loc []int, dims []int, step []int) data.NDUint64 {
	result := nduint64C{}
	nd.SliceInto(&result.NdUint64Common, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *nduint64C) Apply(loc []int, dim int, step int, vals []uint64) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	//	slice := nd.Slice(loc, sliceDim, sliceStep)

	// if slice.Contiguous() {
	// concrete := slice.(*nduint64C)
	// 	implSlice := concrete.Impl
	// 	subset := implSlice[concrete.Start : concrete.Start+len(vals)]
	// 	copy(subset, vals)
	// } else {
	start := loc[dim]
	for i, v := range vals {
		loc[dim] = start + i*step
		nd.Set(loc, v)
	}
	loc[dim] = start
	// }
}

func (nd *nduint64C) ApplySlice(loc []int, step []int, vals data.NDUint64) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)

	idx := slice.NewIndex(0)
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		data.Increment(idx, shape)
	}
	// How to speed up
}

func (nd *nduint64C) CopyFrom(other data.NDUint64) {
	nd.ApplySlice(nd.NewIndex(0), nil, other)
}

func (nd *nduint64C) Unroll() []uint64 {
	// if nd.Contiguous() {
	// 	s := nd.Start
	// 	e := nd.Index(decrement(nd.Dims))
	// 	return nd.Impl[s : e+1]
	// }

	//	fmt.Println(nd)

	length := data.Product(nd.Shape())
	res := make([]uint64, length)

	dimOffsets := data.Offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := data.IDivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *nduint64C) ReshapeFast(newShape []int) (data.NDUint64, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *nduint64C) Reshape(newShape []int) (data.NDUint64, error) {
	result := nduint64C{}
	size := data.Product(newShape)
	currentSize := data.Product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (data.Maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = nd.Start
		result.Impl = nd.Impl
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = slice.Ones(len(newShape))

		result.Offset = data.Offsets(newShape)
		result.OffsetStep = data.Multiply(result.Step, result.Offset)
		return &result, nil
	}

	seriesDim := data.Argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result, nil
}

func (nd *nduint64C) MustReshape(newShape []int) data.NDUint64 {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *nduint64C) Get1(loc int) uint64 {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *nduint64C) Set1(loc int, val uint64) {
	nd.Set([]int{loc}, val)
}

func (nd *nduint64C) Apply1(loc int, step int, vals []uint64) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *nduint64C) Get2(loc1 int, loc2 int) uint64 {
	return nd.Get([]int{loc1, loc2})
}

func (nd *nduint64C) Set2(loc1 int, loc2 int, val uint64) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *nduint64C) Get3(loc1 int, loc2 int, loc3 int) uint64 {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *nduint64C) Set3(loc1 int, loc2 int, loc3 int, val uint64) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func (nd *nduint64C) Maximum() uint64 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v > res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func (nd *nduint64C) Minimum() uint64 {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v < res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func NewUint64CArray(impl unsafe.Pointer, dims []int) data.NDUint64 {
	return newuint64CArray((*[1 << 30]C.ulong)(impl), dims)
}

func newuint64CArray(impl *[1 << 30]C.ulong, dims []int) *nduint64C {
	result := nduint64C{}
	//	size := product(dims)
	result.Start = 0
	result.Impl = impl
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = slice.Ones(len(dims))
	result.Offset = data.Offsets(dims)
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result
}

func makeuint64CArrayForTest(shape []int) *nduint64C {
	goArray := data.ARangeUint64(data.Product(shape)).MustReshape(shape)
	impl := goArray.Unroll()

	v := reflect.Indirect(reflect.ValueOf(&impl))
	slice := (*reflect.SliceHeader)(unsafe.Pointer(v.UnsafeAddr()))
	addr := (*[1 << 30]C.ulong)(unsafe.Pointer(slice.Data))

	return newuint64CArray(addr, shape)
}

type ndintC struct {
	data.NdIntCommon
	//	Impl *C.double
	Impl *[1 << 30]C.int
	//p2 := (*[1<<30]C.int)(unsafe.Pointer(p))
}

// func ArrayFromC(impl *C.double, shape []int) NDFloat64 {
// res := ndintC{}
// 	res.Dims = shape
// 	res.OriginalDims = shape
// 	res.Start = 0
// 	res.Offset = uniform(len(shape), 0)
// 	res.Step = ones(len(shape))
// 	res.Impl = impl
// 	return &res
// }

func (nd *ndintC) Get(loc []int) int {
	return int(nd.Impl[nd.Index(loc)])
}

func (nd *ndintC) Set(loc []int, val int) {
	nd.Impl[nd.Index(loc)] = C.int(val)
}

func (nd *ndintC) Slice(loc []int, dims []int, step []int) data.NDInt {
	result := ndintC{}
	nd.SliceInto(&result.NdIntCommon, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *ndintC) Apply(loc []int, dim int, step int, vals []int) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	//	slice := nd.Slice(loc, sliceDim, sliceStep)

	// if slice.Contiguous() {
	// concrete := slice.(*ndintC)
	// 	implSlice := concrete.Impl
	// 	subset := implSlice[concrete.Start : concrete.Start+len(vals)]
	// 	copy(subset, vals)
	// } else {
	start := loc[dim]
	for i, v := range vals {
		loc[dim] = start + i*step
		nd.Set(loc, v)
	}
	loc[dim] = start
	// }
}

func (nd *ndintC) ApplySlice(loc []int, step []int, vals data.NDInt) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)

	idx := slice.NewIndex(0)
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		data.Increment(idx, shape)
	}
	// How to speed up
}

func (nd *ndintC) CopyFrom(other data.NDInt) {
	nd.ApplySlice(nd.NewIndex(0), nil, other)
}

func (nd *ndintC) Unroll() []int {
	// if nd.Contiguous() {
	// 	s := nd.Start
	// 	e := nd.Index(decrement(nd.Dims))
	// 	return nd.Impl[s : e+1]
	// }

	//	fmt.Println(nd)

	length := data.Product(nd.Shape())
	res := make([]int, length)

	dimOffsets := data.Offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := data.IDivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *ndintC) ReshapeFast(newShape []int) (data.NDInt, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *ndintC) Reshape(newShape []int) (data.NDInt, error) {
	result := ndintC{}
	size := data.Product(newShape)
	currentSize := data.Product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (data.Maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = nd.Start
		result.Impl = nd.Impl
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = slice.Ones(len(newShape))

		result.Offset = data.Offsets(newShape)
		result.OffsetStep = data.Multiply(result.Step, result.Offset)
		return &result, nil
	}

	seriesDim := data.Argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result, nil
}

func (nd *ndintC) MustReshape(newShape []int) data.NDInt {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *ndintC) Get1(loc int) int {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *ndintC) Set1(loc int, val int) {
	nd.Set([]int{loc}, val)
}

func (nd *ndintC) Apply1(loc int, step int, vals []int) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *ndintC) Get2(loc1 int, loc2 int) int {
	return nd.Get([]int{loc1, loc2})
}

func (nd *ndintC) Set2(loc1 int, loc2 int, val int) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *ndintC) Get3(loc1 int, loc2 int, loc3 int) int {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *ndintC) Set3(loc1 int, loc2 int, loc3 int, val int) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func (nd *ndintC) Maximum() int {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v > res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func (nd *ndintC) Minimum() int {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v < res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func NewIntCArray(impl unsafe.Pointer, dims []int) data.NDInt {
	return newintCArray((*[1 << 30]C.int)(impl), dims)
}

func newintCArray(impl *[1 << 30]C.int, dims []int) *ndintC {
	result := ndintC{}
	//	size := product(dims)
	result.Start = 0
	result.Impl = impl
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = slice.Ones(len(dims))
	result.Offset = data.Offsets(dims)
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result
}

func makeintCArrayForTest(shape []int) *ndintC {
	goArray := data.ARangeInt(data.Product(shape)).MustReshape(shape)
	impl := goArray.Unroll()

	v := reflect.Indirect(reflect.ValueOf(&impl))
	slice := (*reflect.SliceHeader)(unsafe.Pointer(v.UnsafeAddr()))
	addr := (*[1 << 30]C.int)(unsafe.Pointer(slice.Data))

	return newintCArray(addr, shape)
}

type nduintC struct {
	data.NdUintCommon
	//	Impl *C.double
	Impl *[1 << 30]C.uint
	//p2 := (*[1<<30]C.int)(unsafe.Pointer(p))
}

// func ArrayFromC(impl *C.double, shape []int) NDFloat64 {
// res := nduintC{}
// 	res.Dims = shape
// 	res.OriginalDims = shape
// 	res.Start = 0
// 	res.Offset = uniform(len(shape), 0)
// 	res.Step = ones(len(shape))
// 	res.Impl = impl
// 	return &res
// }

func (nd *nduintC) Get(loc []int) uint {
	return uint(nd.Impl[nd.Index(loc)])
}

func (nd *nduintC) Set(loc []int, val uint) {
	nd.Impl[nd.Index(loc)] = C.uint(val)
}

func (nd *nduintC) Slice(loc []int, dims []int, step []int) data.NDUint {
	result := nduintC{}
	nd.SliceInto(&result.NdUintCommon, loc, dims, step)
	result.Impl = nd.Impl
	return &result
}

func (nd *nduintC) Apply(loc []int, dim int, step int, vals []uint) {
	sliceDim := nd.NewIndex(1)
	sliceDim[dim] = len(vals)
	sliceStep := nd.NewIndex(1)
	sliceStep[dim] = step
	//	slice := nd.Slice(loc, sliceDim, sliceStep)

	// if slice.Contiguous() {
	// concrete := slice.(*nduintC)
	// 	implSlice := concrete.Impl
	// 	subset := implSlice[concrete.Start : concrete.Start+len(vals)]
	// 	copy(subset, vals)
	// } else {
	start := loc[dim]
	for i, v := range vals {
		loc[dim] = start + i*step
		nd.Set(loc, v)
	}
	loc[dim] = start
	// }
}

func (nd *nduintC) ApplySlice(loc []int, step []int, vals data.NDUint) {
	shape := vals.Shape()
	slice := nd.Slice(loc, shape, step)

	idx := slice.NewIndex(0)
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		slice.Set(idx, vals.Get(idx))
		data.Increment(idx, shape)
	}
	// How to speed up
}

func (nd *nduintC) CopyFrom(other data.NDUint) {
	nd.ApplySlice(nd.NewIndex(0), nil, other)
}

func (nd *nduintC) Unroll() []uint {
	// if nd.Contiguous() {
	// 	s := nd.Start
	// 	e := nd.Index(decrement(nd.Dims))
	// 	return nd.Impl[s : e+1]
	// }

	//	fmt.Println(nd)

	length := data.Product(nd.Shape())
	res := make([]uint, length)

	dimOffsets := data.Offsets(nd.Dims)
	//fmt.Println(dimOffsets)
	for i := 0; i < length; i++ {
		loc := data.IDivMod(i, dimOffsets, nd.Dims)
		//		fmt.Println(i, loc, nd.Index(loc))
		//		fmt.Println(loc,i)
		res[i] = nd.Get(loc)
	}
	return res
}

func (nd *nduintC) ReshapeFast(newShape []int) (data.NDUint, error) {
	if !nd.Contiguous() {
		return nil, errors.New("Array not contiguous")
	}

	return nd.Reshape(newShape)
}

func (nd *nduintC) Reshape(newShape []int) (data.NDUint, error) {
	result := nduintC{}
	size := data.Product(newShape)
	currentSize := data.Product(nd.Shape())

	if size != currentSize {
		return nil, errors.New("Size mismatch")
	}

	reshapeToSeries := (len(newShape) == 1) && (data.Maximum(nd.Shape()) == len(newShape))

	if nd.Contiguous() || !reshapeToSeries {
		result.Start = nd.Start
		result.Impl = nd.Impl
		result.OriginalDims = newShape
		result.Dims = newShape
		result.Step = slice.Ones(len(newShape))

		result.Offset = data.Offsets(newShape)
		result.OffsetStep = data.Multiply(result.Step, result.Offset)
		return &result, nil
	}

	seriesDim := data.Argmax(nd.Shape())
	// Special case 1D
	result.Start = nd.Start
	//result.takeImplementation(nd)
	result.Impl = nd.Impl
	result.OriginalDims = nd.OriginalDims
	result.Dims = newShape
	result.Step = []int{nd.Step[seriesDim]}
	result.Offset = []int{nd.Offset[seriesDim]}
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result, nil
}

func (nd *nduintC) MustReshape(newShape []int) data.NDUint {
	result, e := nd.Reshape(newShape)
	if e != nil {
		panic(e.Error())
	}
	return result
}

func (nd *nduintC) Get1(loc int) uint {
	var idx []int

	if len(nd.Dims) == 1 {
		idx = []int{loc}
	} else {
		idx = nd.NewIndex(0)
		for i := 0; i < len(nd.Dims); i++ {
			if nd.Dims[i] > 1 {
				idx[i] = loc
				break
			}
		}
		//		fmt.Println("nDims>1",idx,nd.Dims,loc)
	}
	return nd.Get(idx)
}

func (nd *nduintC) Set1(loc int, val uint) {
	nd.Set([]int{loc}, val)
}

func (nd *nduintC) Apply1(loc int, step int, vals []uint) {
	for i := 0; i < len(vals); i++ {
		nd.Set1(loc+i*step, vals[i])
	}
}

func (nd *nduintC) Get2(loc1 int, loc2 int) uint {
	return nd.Get([]int{loc1, loc2})
}

func (nd *nduintC) Set2(loc1 int, loc2 int, val uint) {
	nd.Set([]int{loc1, loc2}, val)
}

func (nd *nduintC) Get3(loc1 int, loc2 int, loc3 int) uint {
	return nd.Get([]int{loc1, loc2, loc3})
}

func (nd *nduintC) Set3(loc1 int, loc2 int, loc3 int, val uint) {
	nd.Set([]int{loc1, loc2, loc3}, val)
}

func (nd *nduintC) Maximum() uint {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v > res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func (nd *nduintC) Minimum() uint {
	idx := nd.NewIndex(0)
	res := nd.Get(idx)

	shape := nd.Shape()
	size := data.Product(shape)
	for pos := 0; pos < size; pos++ {
		v := nd.Get(idx)
		if v < res {
			res = v
		}
		data.Increment(idx, shape)
	}
	return res
}

func NewUintCArray(impl unsafe.Pointer, dims []int) data.NDUint {
	return newuintCArray((*[1 << 30]C.uint)(impl), dims)
}

func newuintCArray(impl *[1 << 30]C.uint, dims []int) *nduintC {
	result := nduintC{}
	//	size := product(dims)
	result.Start = 0
	result.Impl = impl
	result.OriginalDims = dims
	result.Dims = dims
	result.Step = slice.Ones(len(dims))
	result.Offset = data.Offsets(dims)
	result.OffsetStep = data.Multiply(result.Step, result.Offset)
	return &result
}

func makeuintCArrayForTest(shape []int) *nduintC {
	goArray := data.ARangeUint(data.Product(shape)).MustReshape(shape)
	impl := goArray.Unroll()

	v := reflect.Indirect(reflect.ValueOf(&impl))
	slice := (*reflect.SliceHeader)(unsafe.Pointer(v.UnsafeAddr()))
	addr := (*[1 << 30]C.uint)(unsafe.Pointer(slice.Data))

	return newuintCArray(addr, shape)
}
